diff -ruN a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
--- a/drivers/gpu/drm/Kconfig	2021-01-09 13:46:25.000000000 +0100
+++ b/drivers/gpu/drm/Kconfig	2021-03-20 15:03:19.000000000 +0100
@@ -296,6 +298,8 @@
 
 	  If M is selected the module will be called vkms.
 
+source "drivers/gpu/drm/evdi/Kconfig"
+
 source "drivers/gpu/drm/exynos/Kconfig"
 
 source "drivers/gpu/drm/rockchip/Kconfig"
diff -ruN a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
--- a/drivers/gpu/drm/Makefile	2021-01-09 13:46:25.000000000 +0100
+++ b/drivers/gpu/drm/Makefile	2021-03-20 15:03:19.000000000 +0100
@@ -81,6 +81,7 @@
 obj-$(CONFIG_DRM_VGEM)	+= vgem/
 obj-$(CONFIG_DRM_VKMS)	+= vkms/
 obj-$(CONFIG_DRM_NOUVEAU) +=nouveau/
+obj-$(CONFIG_DRM_EVDI)	+= evdi/
 obj-$(CONFIG_DRM_EXYNOS) +=exynos/
 obj-$(CONFIG_DRM_ROCKCHIP) +=rockchip/
 obj-$(CONFIG_DRM_GMA500) += gma500/
diff -ruN a/drivers/gpu/drm/evdi/evdi_connector.c b/drivers/gpu/drm/evdi/evdi_connector.c
--- a/drivers/gpu/drm/evdi/evdi_connector.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_connector.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include "evdi_drv.h"
+
+/*
+ * dummy connector to just get EDID,
+ * all EVDI appear to have a DVI-D
+ */
+
+static int evdi_get_modes(struct drm_connector *connector)
+{
+	struct evdi_device *evdi = connector->dev->dev_private;
+	struct edid *edid = NULL;
+	int ret = 0;
+
+	edid = (struct edid *)evdi_painter_get_edid_copy(evdi);
+
+	if (!edid) {
+		drm_connector_update_edid_property(connector, NULL);
+		return 0;
+	}
+
+	ret = drm_connector_update_edid_property(connector, edid);
+	if (!ret)
+		ret = drm_add_edid_modes(connector, edid);
+	else
+		EVDI_ERROR("Failed to set edid modes! error: %d", ret);
+
+	kfree(edid);
+	return ret;
+}
+
+static int evdi_mode_valid(struct drm_connector *connector,
+			   struct drm_display_mode *mode)
+{
+	struct evdi_device *evdi = connector->dev->dev_private;
+	uint32_t mode_area = mode->hdisplay * mode->vdisplay;
+
+	if (evdi->sku_area_limit == 0)
+		return MODE_OK;
+
+	if (mode_area > evdi->sku_area_limit) {
+		EVDI_WARN("(dev=%d) Mode %dx%d@%d rejected\n",
+			evdi->dev_index,
+			mode->hdisplay,
+			mode->vdisplay,
+			drm_mode_vrefresh(mode));
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static enum drm_connector_status
+evdi_detect(struct drm_connector *connector, __always_unused bool force)
+{
+	struct evdi_device *evdi = connector->dev->dev_private;
+
+	EVDI_CHECKPT();
+	if (evdi_painter_is_connected(evdi)) {
+		EVDI_DEBUG("(dev=%d) Painter is connected\n", evdi->dev_index);
+		return connector_status_connected;
+	}
+	EVDI_DEBUG("(dev=%d) Painter is disconnected\n", evdi->dev_index);
+	return connector_status_disconnected;
+}
+
+static void evdi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+	kfree(connector);
+}
+
+static struct drm_connector_helper_funcs evdi_connector_helper_funcs = {
+	.get_modes = evdi_get_modes,
+	.mode_valid = evdi_mode_valid,
+};
+
+static const struct drm_connector_funcs evdi_connector_funcs = {
+	.detect = evdi_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = evdi_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state
+};
+
+int evdi_connector_init(struct drm_device *dev, struct drm_encoder *encoder)
+{
+	struct drm_connector *connector;
+	struct evdi_device *evdi = dev->dev_private;
+
+	connector = kzalloc(sizeof(struct drm_connector), GFP_KERNEL);
+	if (!connector)
+		return -ENOMEM;
+
+	/* TODO: Initialize connector with actual connector type */
+	drm_connector_init(dev, connector, &evdi_connector_funcs,
+			   DRM_MODE_CONNECTOR_DVII);
+	drm_connector_helper_add(connector, &evdi_connector_helper_funcs);
+	connector->polled = DRM_CONNECTOR_POLL_HPD;
+
+	drm_connector_register(connector);
+
+	evdi->conn = connector;
+
+	drm_connector_attach_encoder(connector, encoder);
+
+	return 0;
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_cursor.c b/drivers/gpu/drm/evdi/evdi_cursor.c
--- a/drivers/gpu/drm/evdi/evdi_cursor.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_cursor.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * evdi_cursor.c
+ *
+ * Copyright (c) 2016 The Chromium OS Authors
+ * Copyright (c) 2016 - 2017 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <linux/compiler.h>
+#include <linux/mutex.h>
+
+#include "evdi_cursor.h"
+#include "evdi_drv.h"
+
+/*
+ * EVDI drm cursor private structure.
+ */
+struct evdi_cursor {
+	bool enabled;
+	int32_t x;
+	int32_t y;
+	uint32_t width;
+	uint32_t height;
+	int32_t hot_x;
+	int32_t hot_y;
+	uint32_t pixel_format;
+	uint32_t stride;
+	struct evdi_gem_object *obj;
+	struct mutex lock;
+};
+
+static void evdi_cursor_set_gem(struct evdi_cursor *cursor,
+				struct evdi_gem_object *obj)
+{
+	if (obj)
+		drm_gem_object_get(&obj->base);
+	if (cursor->obj)
+		drm_gem_object_put(&cursor->obj->base);
+
+	cursor->obj = obj;
+}
+
+struct evdi_gem_object *evdi_cursor_gem(struct evdi_cursor *cursor)
+{
+	return cursor->obj;
+}
+
+int evdi_cursor_init(struct evdi_cursor **cursor)
+{
+	if (WARN_ON(*cursor))
+		return -EINVAL;
+
+	*cursor = kzalloc(sizeof(struct evdi_cursor), GFP_KERNEL);
+	if (*cursor) {
+		mutex_init(&(*cursor)->lock);
+		return 0;
+	} else {
+		return -ENOMEM;
+	}
+}
+
+void evdi_cursor_lock(struct evdi_cursor *cursor)
+{
+	mutex_lock(&cursor->lock);
+}
+
+void evdi_cursor_unlock(struct evdi_cursor *cursor)
+{
+	mutex_unlock(&cursor->lock);
+}
+
+void evdi_cursor_free(struct evdi_cursor *cursor)
+{
+	if (WARN_ON(!cursor))
+		return;
+	evdi_cursor_set_gem(cursor, NULL);
+	kfree(cursor);
+}
+
+bool evdi_cursor_enabled(struct evdi_cursor *cursor)
+{
+	return cursor->enabled;
+}
+
+void evdi_cursor_enable(struct evdi_cursor *cursor, bool enable)
+{
+	evdi_cursor_lock(cursor);
+	cursor->enabled = enable;
+	if (!enable)
+		evdi_cursor_set_gem(cursor, NULL);
+	evdi_cursor_unlock(cursor);
+}
+
+void evdi_cursor_set(struct evdi_cursor *cursor,
+		     struct evdi_gem_object *obj,
+		     uint32_t width, uint32_t height,
+		     int32_t hot_x, int32_t hot_y,
+		     uint32_t pixel_format, uint32_t stride)
+{
+	int err = 0;
+
+	evdi_cursor_lock(cursor);
+	if (obj && !obj->vmapping)
+		err = evdi_gem_vmap(obj);
+
+	if (err != 0) {
+		EVDI_ERROR("Failed to map cursor.\n");
+		obj = NULL;
+	}
+
+	cursor->enabled = obj != NULL;
+	cursor->width = width;
+	cursor->height = height;
+	cursor->hot_x = hot_x;
+	cursor->hot_y = hot_y;
+	cursor->pixel_format = pixel_format;
+	cursor->stride = stride;
+	evdi_cursor_set_gem(cursor, obj);
+
+	evdi_cursor_unlock(cursor);
+}
+
+void evdi_cursor_move(struct evdi_cursor *cursor, int32_t x, int32_t y)
+{
+	evdi_cursor_lock(cursor);
+	cursor->x = x;
+	cursor->y = y;
+	evdi_cursor_unlock(cursor);
+}
+
+static inline uint32_t blend_component(uint32_t pixel,
+				  uint32_t blend,
+				  uint32_t alpha)
+{
+	uint32_t pre_blend = (pixel * (255 - alpha) + blend * alpha);
+
+	return (pre_blend + ((pre_blend + 1) << 8)) >> 16;
+}
+
+static inline uint32_t blend_alpha(const uint32_t pixel_val32,
+				uint32_t blend_val32)
+{
+	uint32_t alpha = (blend_val32 >> 24);
+
+	return blend_component(pixel_val32 & 0xff,
+			       blend_val32 & 0xff, alpha) |
+			blend_component((pixel_val32 & 0xff00) >> 8,
+				(blend_val32 & 0xff00) >> 8, alpha) << 8 |
+			blend_component((pixel_val32 & 0xff0000) >> 16,
+				(blend_val32 & 0xff0000) >> 16, alpha) << 16;
+}
+
+static int evdi_cursor_compose_pixel(char __user *buffer,
+				     int const cursor_value,
+				     int const fb_value,
+				     int cmd_offset)
+{
+	int const composed_value = blend_alpha(fb_value, cursor_value);
+
+	return copy_to_user(buffer + cmd_offset, &composed_value, 4);
+}
+
+int evdi_cursor_compose_and_copy(struct evdi_cursor *cursor,
+				 struct evdi_framebuffer *ufb,
+				 char __user *buffer,
+				 int buf_byte_stride)
+{
+	int x, y;
+	struct drm_framebuffer *fb = &ufb->base;
+	const int h_cursor_w = cursor->width >> 1;
+	const int h_cursor_h = cursor->height >> 1;
+	uint32_t *cursor_buffer = NULL;
+	uint32_t bytespp = 0;
+
+	if (!cursor->enabled)
+		return 0;
+
+	if (!cursor->obj)
+		return -EINVAL;
+
+	if (!cursor->obj->vmapping)
+		return -EINVAL;
+
+	bytespp = evdi_fb_get_bpp(cursor->pixel_format);
+	bytespp = DIV_ROUND_UP(bytespp, 8);
+	if (bytespp != 4) {
+		EVDI_ERROR("Unsupported cursor format bpp=%u\n", bytespp);
+		return -EINVAL;
+	}
+
+	if (cursor->width * cursor->height * bytespp >
+	    cursor->obj->base.size){
+		EVDI_ERROR("Wrong cursor size\n");
+		return -EINVAL;
+	}
+
+	cursor_buffer = (uint32_t *)cursor->obj->vmapping;
+
+	for (y = -h_cursor_h; y < h_cursor_h; ++y) {
+		for (x = -h_cursor_w; x < h_cursor_w; ++x) {
+			uint32_t curs_val;
+			int *fbsrc;
+			int fb_value;
+			int cmd_offset;
+			int cursor_pix;
+			int const mouse_pix_x = cursor->x + x + h_cursor_w;
+			int const mouse_pix_y = cursor->y + y + h_cursor_h;
+			bool const is_pix_sane =
+				mouse_pix_x >= 0 &&
+				mouse_pix_y >= 0 &&
+				mouse_pix_x < fb->width &&
+				mouse_pix_y < fb->height;
+
+			if (!is_pix_sane)
+				continue;
+
+			cursor_pix = h_cursor_w+x +
+				    (h_cursor_h+y)*cursor->width;
+			curs_val = le32_to_cpu(cursor_buffer[cursor_pix]);
+			fbsrc = (int *)ufb->obj->vmapping;
+			fb_value = *(fbsrc + ((fb->pitches[0]>>2) *
+						  mouse_pix_y + mouse_pix_x));
+			cmd_offset = (buf_byte_stride * mouse_pix_y) +
+						       (mouse_pix_x * bytespp);
+			if (evdi_cursor_compose_pixel(buffer,
+						      curs_val,
+						      fb_value,
+						      cmd_offset)) {
+				EVDI_ERROR("Failed to compose cursor pixel\n");
+				return -EFAULT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void evdi_cursor_position(struct evdi_cursor *cursor, int32_t *x, int32_t *y)
+{
+	*x = cursor->x;
+	*y = cursor->y;
+}
+
+void evdi_cursor_hotpoint(struct evdi_cursor *cursor,
+			  int32_t *hot_x, int32_t *hot_y)
+{
+	*hot_x = cursor->hot_x;
+	*hot_y = cursor->hot_y;
+}
+
+void evdi_cursor_size(struct evdi_cursor *cursor,
+		      uint32_t *width, uint32_t *height)
+{
+	*width = cursor->width;
+	*height = cursor->height;
+}
+
+void evdi_cursor_format(struct evdi_cursor *cursor, uint32_t *format)
+{
+	*format = cursor->pixel_format;
+}
+
+void evdi_cursor_stride(struct evdi_cursor *cursor, uint32_t *stride)
+{
+	*stride = cursor->stride;
+}
+
diff -ruN a/drivers/gpu/drm/evdi/evdi_cursor.h b/drivers/gpu/drm/evdi/evdi_cursor.h
--- a/drivers/gpu/drm/evdi/evdi_cursor.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_cursor.h	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ *
+ * evdi_cursor.h
+ *
+ * Copyright (c) 2016 The Chromium OS Authors
+ * Copyright (c) 2016 - 2017 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _EVDI_CURSOR_H_
+#define _EVDI_CURSOR_H_
+
+#include <linux/module.h>
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+
+struct evdi_cursor;
+struct evdi_framebuffer;
+struct evdi_gem_object;
+
+int evdi_cursor_init(struct evdi_cursor **cursor);
+void evdi_cursor_free(struct evdi_cursor *cursor);
+void evdi_cursor_lock(struct evdi_cursor *cursor);
+void evdi_cursor_unlock(struct evdi_cursor *cursor);
+bool evdi_cursor_enabled(struct evdi_cursor *cursor);
+void evdi_cursor_enable(struct evdi_cursor *cursor, bool enabled);
+void evdi_cursor_set(struct evdi_cursor *cursor,
+		     struct evdi_gem_object *obj,
+		     uint32_t width, uint32_t height,
+		     int32_t hot_x, int32_t hot_y,
+		     uint32_t pixel_format, uint32_t stride);
+
+void evdi_cursor_move(struct evdi_cursor *cursor, int32_t x, int32_t y);
+void evdi_cursor_position(struct evdi_cursor *cursor, int32_t *x, int32_t *y);
+void evdi_cursor_hotpoint(struct evdi_cursor *cursor,
+			  int32_t *hot_x, int32_t *hot_y);
+void evdi_cursor_size(struct evdi_cursor *cursor,
+		      uint32_t *width, uint32_t *height);
+void evdi_cursor_format(struct evdi_cursor *cursor, uint32_t *format);
+void evdi_cursor_stride(struct evdi_cursor *cursor, uint32_t *stride);
+struct evdi_gem_object *evdi_cursor_gem(struct evdi_cursor *cursor);
+
+int evdi_cursor_compose_and_copy(struct evdi_cursor *cursor,
+				 struct evdi_framebuffer *ufb,
+				 char __user *buffer,
+				 int buf_byte_stride);
+#endif
diff -ruN a/drivers/gpu/drm/evdi/evdi_debug.c b/drivers/gpu/drm/evdi/evdi_debug.c
--- a/drivers/gpu/drm/evdi/evdi_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_debug.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2015 - 2016 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "evdi_debug.h"
+
+unsigned int evdi_loglevel = EVDI_LOGLEVEL_DEBUG;
+
+module_param_named(initial_loglevel, evdi_loglevel, int, 0400);
+MODULE_PARM_DESC(initial_loglevel, "Initial log level");
diff -ruN a/drivers/gpu/drm/evdi/evdi_debug.h b/drivers/gpu/drm/evdi/evdi_debug.h
--- a/drivers/gpu/drm/evdi/evdi_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_debug.h	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Copyright (c) 2015 - 2016 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_DEBUG_H
+#define EVDI_DEBUG_H
+
+#define EVDI_LOGLEVEL_ALWAYS  0
+#define EVDI_LOGLEVEL_FATAL   1
+#define EVDI_LOGLEVEL_ERROR   2
+#define EVDI_LOGLEVEL_WARN    3
+#define EVDI_LOGLEVEL_INFO    4
+#define EVDI_LOGLEVEL_DEBUG   5
+#define EVDI_LOGLEVEL_VERBOSE 6
+
+extern unsigned int evdi_loglevel;
+
+#define EVDI_PRINTK(KERN_LEVEL, lEVEL, FORMAT_STR, ...)	do { \
+	if (lEVEL <= evdi_loglevel) {\
+		printk(KERN_LEVEL "evdi: " FORMAT_STR, ##__VA_ARGS__); \
+	} \
+} while (0)
+
+#define EVDI_FATAL(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_CRIT, EVDI_LOGLEVEL_FATAL,\
+		    "[F] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_ERROR(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_ERR, EVDI_LOGLEVEL_ERROR,\
+		    "[E] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_WARN(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_WARNING, EVDI_LOGLEVEL_WARN,\
+		    "[W] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_INFO(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_DEFAULT, EVDI_LOGLEVEL_INFO,\
+		    "[I] " FORMAT_STR, ##__VA_ARGS__)
+
+#define EVDI_DEBUG(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_DEFAULT, EVDI_LOGLEVEL_DEBUG,\
+		    "[D] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_VERBOSE(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_DEFAULT, EVDI_LOGLEVEL_VERBOSE,\
+		    "[V] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_CHECKPT() EVDI_VERBOSE("\n")
+#define EVDI_ENTER() EVDI_VERBOSE("enter\n")
+#define EVDI_EXIT() EVDI_VERBOSE("exit\n")
+
+#endif /* EVDI_DEBUG_H */
+
diff -ruN a/drivers/gpu/drm/evdi/evdi_drv.c b/drivers/gpu/drm/evdi/evdi_drv.c
--- a/drivers/gpu/drm/evdi/evdi_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_drv.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,678 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+
+#include "evdi_drv.h"
+#include <uapi/drm/evdi_drm.h>
+#include "evdi_debug.h"
+#include "evdi_cursor.h"
+
+MODULE_AUTHOR("DisplayLink (UK) Ltd.");
+MODULE_DESCRIPTION("Extensible Virtual Display Interface");
+MODULE_LICENSE("GPL");
+
+#define EVDI_DEVICE_COUNT_MAX 16
+#define MAX_EVDI_USB_ADDR 10
+
+static struct evdi_context {
+	struct device *root_dev;
+	unsigned int dev_count;
+	struct platform_device *devices[EVDI_DEVICE_COUNT_MAX];
+	struct notifier_block usb_notifier;
+	struct mutex lock;
+} evdi_context;
+
+#define evdi_context_lock(ctx) \
+		mutex_lock(&ctx->lock)
+
+#define evdi_context_unlock(ctx) \
+		mutex_unlock(&ctx->lock)
+
+
+struct evdi_platform_device_data {
+	struct drm_device *drm_dev;
+	struct device *parent;
+	bool symlinked;
+};
+
+static int evdi_platform_drv_usb(__always_unused struct notifier_block *nb,
+		unsigned long action,
+		void *data)
+{
+	struct usb_device *usb_dev = (struct usb_device *)(data);
+	struct platform_device *pdev;
+	int i = 0;
+
+	if (!usb_dev)
+		return 0;
+	if (action != BUS_NOTIFY_DEL_DEVICE)
+		return 0;
+
+	evdi_context_lock((&evdi_context));
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		pdev = evdi_context.devices[i];
+		if (!pdev)
+			continue;
+		evdi_platform_device_unlink_if_linked_with(pdev, &usb_dev->dev);
+		if (pdev->dev.parent == &usb_dev->dev) {
+			EVDI_INFO("Parent USB removed. Removing evdi.%d\n", i);
+			platform_device_unregister(pdev);
+			evdi_context.dev_count--;
+			evdi_context.devices[i] = NULL;
+		}
+	}
+	evdi_context_unlock((&evdi_context));
+
+	return 0;
+}
+
+static int evdi_context_get_free_idx(struct evdi_context *ctx)
+{
+	int i;
+
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		if (ctx->devices[i] == NULL)
+			return i;
+	}
+	return -ENOMEM;
+}
+
+bool evdi_platform_device_is_free(struct platform_device *pdev)
+{
+	struct evdi_platform_device_data *data =
+		(struct evdi_platform_device_data *)platform_get_drvdata(pdev);
+	struct evdi_device *evdi = data->drm_dev->dev_private;
+
+	if (evdi && !evdi_painter_is_connected(evdi) &&
+	    !data->symlinked)
+		return true;
+	return false;
+}
+
+void evdi_platform_device_link(struct platform_device *pdev,
+				      struct device *parent)
+{
+	struct evdi_platform_device_data *data = NULL;
+	int ret = 0;
+
+	if (!parent || !pdev)
+		return;
+
+	data = (struct evdi_platform_device_data *)platform_get_drvdata(pdev);
+	if (!evdi_platform_device_is_free(pdev)) {
+		EVDI_FATAL("Device is already attached can't symlink again\n");
+		return;
+	}
+
+	ret = sysfs_create_link(&pdev->dev.kobj, &parent->kobj, "device");
+	if (ret) {
+		EVDI_FATAL("Failed to create sysfs link to parent device\n");
+	} else {
+		data->symlinked = true;
+		data->parent = parent;
+	}
+}
+
+void evdi_platform_device_unlink_if_linked_with(struct platform_device *pdev,
+				struct device *parent)
+{
+	struct evdi_platform_device_data *data =
+		(struct evdi_platform_device_data *)platform_get_drvdata(pdev);
+
+	if (parent && data->parent == parent) {
+		sysfs_remove_link(&pdev->dev.kobj, "device");
+		data->symlinked = false;
+		data->parent = NULL;
+		EVDI_INFO("Detached from parent device\n");
+	}
+}
+
+static struct drm_driver driver;
+
+struct drm_ioctl_desc evdi_painter_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(EVDI_CONNECT, evdi_painter_connect_ioctl,
+				DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_REQUEST_UPDATE,
+				evdi_painter_request_update_ioctl,
+				DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_GRABPIX, evdi_painter_grabpix_ioctl,
+				DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_DDCCI_RESPONSE,
+				evdi_painter_ddcci_response_ioctl,
+				DRM_UNLOCKED),
+};
+
+static const struct vm_operations_struct evdi_gem_vm_ops = {
+	.fault = evdi_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static const struct file_operations evdi_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.mmap = evdi_drm_gem_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+	.unlocked_ioctl = drm_ioctl,
+	.release = drm_release,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = evdi_compat_ioctl,
+#endif
+	.llseek = noop_llseek,
+};
+
+static int evdi_enable_vblank(__always_unused struct drm_device *dev,
+	__always_unused unsigned int pipe)
+{
+	return 1;
+}
+
+static void evdi_disable_vblank(__always_unused struct drm_device *dev,
+	__always_unused unsigned int pipe)
+{
+}
+
+static struct drm_driver driver = {
+	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,
+	.load = evdi_driver_load,
+	.unload = evdi_driver_unload,
+	.preclose = evdi_driver_preclose,
+
+	/* gem hooks */
+	.gem_free_object = evdi_gem_free_object,
+	.gem_vm_ops = &evdi_gem_vm_ops,
+
+	.dumb_create = evdi_dumb_create,
+	.dumb_map_offset = evdi_gem_mmap,
+	.dumb_destroy = drm_gem_dumb_destroy,
+
+	.ioctls = evdi_painter_ioctls,
+	.num_ioctls = ARRAY_SIZE(evdi_painter_ioctls),
+
+	.fops = &evdi_driver_fops,
+
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.gem_prime_import = evdi_gem_prime_import,
+	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+	.gem_prime_export = evdi_gem_prime_export,
+
+	.enable_vblank = evdi_enable_vblank,
+	.disable_vblank = evdi_disable_vblank,
+
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+	.patchlevel = DRIVER_PATCHLEVEL,
+};
+
+static struct platform_device *evdi_platform_drv_get_free_device(
+				struct evdi_context *ctx)
+{
+	int i;
+	struct platform_device *pdev = NULL;
+
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		pdev = ctx->devices[i];
+		if (pdev && evdi_platform_device_is_free(pdev))
+			return pdev;
+	}
+	return NULL;
+}
+
+static struct platform_device *evdi_platform_drv_create_new_device(
+				struct evdi_context *ctx)
+{
+	struct platform_device_info pdevinfo = {
+		.parent = NULL,
+		.name = "evdi",
+		.id = evdi_context_get_free_idx(ctx),
+		.res = NULL,
+		.num_res = 0,
+		.data = NULL,
+		.size_data = 0,
+		.dma_mask = DMA_BIT_MASK(32),
+	};
+
+	if (pdevinfo.id < 0 || ctx->dev_count >= EVDI_DEVICE_COUNT_MAX) {
+		EVDI_ERROR("Evdi device add failed. Too many devices.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	ctx->devices[pdevinfo.id] = platform_device_register_full(&pdevinfo);
+	if (dma_set_mask(&evdi_context.devices[evdi_context.dev_count]->dev,
+			 DMA_BIT_MASK(64))) {
+		EVDI_DEBUG("Unable to change dma mask to 64 bit. ");
+		EVDI_DEBUG("Sticking with 32 bit\n");
+	}
+
+	ctx->dev_count++;
+	return ctx->devices[pdevinfo.id];
+}
+
+static int evdi_add_device(struct evdi_context *ctx, struct device *parent)
+{
+	struct platform_device *pdev = NULL;
+
+	evdi_context_lock(ctx);
+	if (parent)
+		pdev = evdi_platform_drv_get_free_device(ctx);
+
+	if (IS_ERR_OR_NULL(pdev))
+		pdev = evdi_platform_drv_create_new_device(ctx);
+	evdi_context_unlock(ctx);
+
+	if (IS_ERR_OR_NULL(pdev))
+		return -EINVAL;
+
+	evdi_platform_device_link(pdev, parent);
+	return 0;
+}
+
+int evdi_driver_setup_early(struct drm_device *dev)
+{
+	struct platform_device *platdev = NULL;
+	struct evdi_device *evdi;
+	int ret;
+
+	EVDI_CHECKPT();
+	evdi = kzalloc(sizeof(struct evdi_device), GFP_KERNEL);
+	if (!evdi)
+		return -ENOMEM;
+
+	evdi->ddev = dev;
+	dev->dev_private = evdi;
+
+	ret =	evdi_cursor_init(&evdi->cursor);
+	if (ret)
+		goto err;
+
+	EVDI_CHECKPT();
+	evdi_modeset_init(dev);
+
+	if (ret)
+		goto err;
+
+#ifdef CONFIG_FB
+	ret = evdi_fbdev_init(dev);
+	if (ret)
+		goto err;
+#endif /* CONFIG_FB */
+
+	ret = drm_vblank_init(dev, 1);
+	if (ret)
+		goto err_fb;
+
+	ret = evdi_painter_init(evdi);
+	if (ret)
+		goto err_fb;
+
+	drm_kms_helper_poll_init(dev);
+
+	platdev = to_platform_device(dev->dev);
+	platform_set_drvdata(platdev, dev);
+
+	return 0;
+
+err_fb:
+#ifdef CONFIG_FB
+	evdi_fbdev_cleanup(dev);
+#endif /* CONFIG_FB */
+err:
+	kfree(evdi);
+	EVDI_ERROR("%d\n", ret);
+	if (evdi->cursor)
+		evdi_cursor_free(evdi->cursor);
+	return ret;
+}
+
+static int evdi_platform_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct drm_device *dev = NULL;
+	struct evdi_platform_device_data *data =
+		kzalloc(sizeof(struct evdi_platform_device_data), GFP_KERNEL);
+
+	EVDI_CHECKPT();
+
+	dev = drm_dev_alloc(&driver, &pdev->dev);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	ret = evdi_driver_setup_early(dev);
+	if (ret)
+		goto err_free;
+
+	ret = drm_dev_register(dev, 0);
+	if (ret)
+		goto err_free;
+	else {
+		data->drm_dev = dev;
+		data->symlinked = false;
+		platform_set_drvdata(pdev, data);
+	}
+
+	evdi_driver_setup_late(dev);
+
+	return 0;
+
+err_free:
+	drm_dev_put(dev);
+	kfree(data);
+	return ret;
+}
+
+static int evdi_platform_remove(struct platform_device *pdev)
+{
+	struct evdi_platform_device_data *data =
+		(struct evdi_platform_device_data *)platform_get_drvdata(pdev);
+
+	EVDI_CHECKPT();
+
+	drm_dev_unplug(data->drm_dev);
+	kfree(data);
+
+	return 0;
+}
+
+static void evdi_remove_all(void)
+{
+	int i;
+
+	EVDI_DEBUG("removing all evdi devices\n");
+	evdi_context_lock((&evdi_context));
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		if (evdi_context.devices[i]) {
+			EVDI_DEBUG("removing evdi %d\n", i);
+
+			platform_device_unregister(evdi_context.devices[i]);
+			evdi_context.dev_count--;
+			evdi_context.devices[i] = NULL;
+		}
+	}
+	evdi_context.dev_count = 0;
+	evdi_context_unlock((&evdi_context));
+}
+
+static struct platform_driver evdi_platform_driver = {
+	.probe = evdi_platform_probe,
+	.remove = evdi_platform_remove,
+	.driver = {
+			 .name = "evdi",
+			 .mod_name = KBUILD_MODNAME,
+			 .owner = THIS_MODULE,
+	}
+};
+
+static ssize_t version_show(__always_unused struct device *dev,
+				__always_unused struct device_attribute *attr,
+				char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u.%u.%u\n", DRIVER_MAJOR,
+			DRIVER_MINOR, DRIVER_PATCHLEVEL);
+}
+
+static ssize_t count_show(__always_unused struct device *dev,
+				__always_unused struct device_attribute *attr,
+				char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", evdi_context.dev_count);
+}
+
+struct evdi_usb_addr {
+	int addr[MAX_EVDI_USB_ADDR];
+	int len;
+	struct usb_device *usb;
+};
+
+static int evdi_platform_device_attach(struct device *device,
+		struct evdi_usb_addr *parent_addr);
+
+static ssize_t add_device_with_usb_path(struct device *dev,
+			 const char *buf, size_t count)
+{
+	char *usb_path = kstrdup(buf, GFP_KERNEL);
+	char *temp_path = usb_path;
+	char *bus_token = NULL;
+	char *usb_token = NULL;
+	char *usb_token_copy = NULL;
+	char *itf_token = NULL;
+	char *token = NULL;
+	char *bus = NULL;
+	char *port = NULL;
+	struct evdi_usb_addr usb_addr;
+
+	memset(&usb_addr, 0, sizeof(usb_addr));
+	temp_path = strnstr(temp_path, "usb:", count);
+	if (!temp_path)
+		goto err_parse_usb_path;
+
+
+	temp_path = strim(temp_path);
+
+	bus_token = strsep(&temp_path, ":");
+	if (!bus_token)
+		goto err_parse_usb_path;
+
+	usb_token = strsep(&temp_path, ":");
+	if (!usb_token)
+		goto err_parse_usb_path;
+
+	itf_token = strsep(&temp_path, ":");
+
+	token = usb_token_copy = kstrdup(usb_token, GFP_KERNEL);
+	bus = strsep(&token, "-");
+	if (!bus)
+		goto err_parse_usb_path;
+	if (kstrtouint(bus, 10, &usb_addr.addr[usb_addr.len++]))
+		goto err_parse_usb_path;
+
+	do {
+		port = strsep(&token, ".");
+		if (!port)
+			goto err_parse_usb_path;
+		if (kstrtouint(port, 10, &usb_addr.addr[usb_addr.len++]))
+			goto err_parse_usb_path;
+	} while (token && port && usb_addr.len < MAX_EVDI_USB_ADDR);
+
+	if (evdi_platform_device_attach(dev, &usb_addr) != 0) {
+		EVDI_ERROR("Unable to attach to: %s\n", buf);
+		kfree(usb_path);
+		kfree(usb_token_copy);
+		return -EINVAL;
+	}
+
+	EVDI_INFO("Attaching to %s:%s\n", bus_token, usb_token);
+	kfree(usb_path);
+	kfree(usb_token_copy);
+	return count;
+
+err_parse_usb_path:
+	EVDI_ERROR("Unable to parse usb path: %s", buf);
+	kfree(usb_path);
+	kfree(usb_token_copy);
+	return -EINVAL;
+}
+
+static int find_usb_device_at_path(struct usb_device *usb, void *data)
+{
+	struct evdi_usb_addr *find_path = (struct evdi_usb_addr *)(data);
+	struct usb_device *pdev = usb;
+	int port = 0;
+	int i;
+
+	i = find_path->len - 1;
+	while (pdev != NULL && i >= 0 && i < MAX_EVDI_USB_ADDR) {
+		port = pdev->portnum;
+		if (port == 0)
+			port = pdev->bus->busnum;
+
+		if (port != find_path->addr[i])
+			return 0;
+
+		if (pdev->parent == NULL && i == 0) {
+			find_path->usb = usb;
+			return 1;
+		}
+		pdev = pdev->parent;
+		i--;
+	}
+
+	return 0;
+}
+
+int evdi_platform_device_attach(struct device *device,
+		struct evdi_usb_addr *parent_addr)
+{
+	struct device *parent = NULL;
+
+	if (!parent_addr)
+		return -EINVAL;
+
+	if (!usb_for_each_dev(parent_addr, find_usb_device_at_path) ||
+	    !parent_addr->usb)
+		return -EINVAL;
+
+	parent = &parent_addr->usb->dev;
+	return evdi_add_device(&evdi_context, parent);
+}
+
+static ssize_t add_store(struct device *dev,
+			 __always_unused struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	unsigned int val;
+
+	if (strnstr(buf, "usb:", count))
+		return add_device_with_usb_path(dev, buf, count);
+
+	if (kstrtouint(buf, 10, &val)) {
+		EVDI_ERROR("Invalid device count \"%s\"\n", buf);
+		return -EINVAL;
+	}
+	if (val == 0) {
+		EVDI_WARN("Adding 0 devices has no effect\n");
+		return count;
+	}
+	if (val > EVDI_DEVICE_COUNT_MAX - evdi_context.dev_count) {
+		EVDI_ERROR("Evdi device add failed. Too many devices.\n");
+		return -EINVAL;
+	}
+
+	EVDI_DEBUG("Increasing device count to %u\n",
+			evdi_context.dev_count + val);
+	while (val-- && evdi_add_device(&evdi_context, NULL) == 0)
+		;
+
+	return count;
+}
+
+static ssize_t remove_all_store(__always_unused struct device *dev,
+				__always_unused struct device_attribute *attr,
+				__always_unused const char *buf,
+				size_t count)
+{
+	evdi_remove_all();
+	return count;
+}
+
+static ssize_t loglevel_show(__always_unused struct device *dev,
+				__always_unused struct device_attribute *attr,
+				char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", evdi_loglevel);
+}
+
+static ssize_t loglevel_store(__always_unused struct device *dev,
+				__always_unused struct device_attribute *attr,
+				const char *buf,
+				size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 10, &val)) {
+		EVDI_ERROR("Unable to parse %u\n", val);
+		return -EINVAL;
+	}
+	if (val > EVDI_LOGLEVEL_VERBOSE) {
+		EVDI_ERROR("Invalid loglevel %u\n", val);
+		return -EINVAL;
+	}
+
+	EVDI_INFO("Setting loglevel to %u\n", val);
+	evdi_loglevel = val;
+	return count;
+}
+
+static struct device_attribute evdi_device_attributes[] = {
+	__ATTR_RO(count),
+	__ATTR_RO(version),
+	__ATTR_RW(loglevel),
+	__ATTR_WO(add),
+	__ATTR_WO(remove_all)
+};
+
+static int __init evdi_init(void)
+{
+	int i;
+
+	EVDI_INFO("Initialising logging on level %u\n", evdi_loglevel);
+	EVDI_INFO("Atomic driver:%s",
+		(driver.driver_features & DRIVER_ATOMIC) ? "yes" : "no");
+	evdi_context.root_dev = root_device_register("evdi");
+	evdi_context.usb_notifier.notifier_call = evdi_platform_drv_usb;
+	mutex_init(&evdi_context.lock);
+
+	usb_register_notify(&evdi_context.usb_notifier);
+	if (!PTR_RET(evdi_context.root_dev))
+		for (i = 0; i < ARRAY_SIZE(evdi_device_attributes); i++) {
+			device_create_file(evdi_context.root_dev,
+						 &evdi_device_attributes[i]);
+		}
+
+	return platform_driver_register(&evdi_platform_driver);
+}
+
+static void __exit evdi_exit(void)
+{
+	int i;
+
+	EVDI_CHECKPT();
+	evdi_remove_all();
+
+	usb_unregister_notify(&evdi_context.usb_notifier);
+	platform_driver_unregister(&evdi_platform_driver);
+
+	if (!PTR_RET(evdi_context.root_dev)) {
+		for (i = 0; i < ARRAY_SIZE(evdi_device_attributes); i++) {
+			device_remove_file(evdi_context.root_dev,
+						 &evdi_device_attributes[i]);
+		}
+		root_device_unregister(evdi_context.root_dev);
+	}
+}
+
+module_init(evdi_init);
+module_exit(evdi_exit);
+
+bool evdi_enable_cursor_blending __read_mostly = true;
+module_param_named(enable_cursor_blending,
+			 evdi_enable_cursor_blending, bool, 0644);
+MODULE_PARM_DESC(enable_cursor_blending, "Enables cursor compositing on user supplied framebuffer via EVDI_GRABPIX ioctl. (default: true)");
+
diff -ruN a/drivers/gpu/drm/evdi/evdi_drv.h b/drivers/gpu/drm/evdi/evdi_drv.h
--- a/drivers/gpu/drm/evdi/evdi_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_drv.h	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,173 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_DRV_H
+#define EVDI_DRV_H
+
+#include <linux/module.h>
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_rect.h>
+# include <drm/drm_gem.h>
+#include <drm/drm_cache.h>
+#include <linux/dma-resv.h>
+#include "evdi_debug.h"
+
+#define DRIVER_NAME   "evdi"
+#define DRIVER_DESC   "Extensible Virtual Display Interface"
+#define DRIVER_DATE   "20201210"
+
+
+#define DRIVER_MAJOR      1
+#define DRIVER_MINOR      9
+#define DRIVER_PATCHLEVEL 0
+
+struct evdi_fbdev;
+struct evdi_painter;
+
+extern bool evdi_enable_cursor_blending __read_mostly;
+
+struct evdi_device {
+	struct drm_device *ddev;
+	struct drm_connector *conn;
+	struct evdi_cursor *cursor;
+	uint32_t sku_area_limit;
+
+	struct evdi_fbdev *fbdev;
+	struct evdi_painter *painter;
+	struct i2c_adapter *i2c_adapter;
+
+	atomic_t frame_count;
+
+	int dev_index;
+};
+
+struct evdi_gem_object {
+	struct drm_gem_object base;
+	struct page **pages;
+	void *vmapping;
+	struct sg_table *sg;
+	struct dma_resv *resv;
+	struct dma_resv _resv;
+};
+
+#define to_evdi_bo(x) container_of(x, struct evdi_gem_object, base)
+
+struct evdi_framebuffer {
+	struct drm_framebuffer base;
+	struct evdi_gem_object *obj;
+	bool active;
+};
+
+#define to_evdi_fb(x) container_of(x, struct evdi_framebuffer, base)
+
+/* modeset */
+void evdi_modeset_init(struct drm_device *dev);
+void evdi_modeset_cleanup(struct drm_device *dev);
+int evdi_connector_init(struct drm_device *dev, struct drm_encoder *encoder);
+
+struct drm_encoder *evdi_encoder_init(struct drm_device *dev);
+
+int evdi_driver_load(struct drm_device *dev, unsigned long flags);
+void evdi_driver_unload(struct drm_device *dev);
+void evdi_driver_preclose(struct drm_device *dev, struct drm_file *file_priv);
+
+#ifdef CONFIG_COMPAT
+long evdi_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+
+#ifdef CONFIG_FB
+int evdi_fbdev_init(struct drm_device *dev);
+void evdi_fbdev_cleanup(struct drm_device *dev);
+void evdi_fbdev_unplug(struct drm_device *dev);
+#endif /* CONFIG_FB */
+struct drm_framebuffer *evdi_fb_user_fb_create(
+				struct drm_device *dev,
+				struct drm_file *file,
+				const struct drm_mode_fb_cmd2 *mode_cmd);
+
+int evdi_dumb_create(struct drm_file *file_priv,
+		     struct drm_device *dev, struct drm_mode_create_dumb *args);
+int evdi_gem_mmap(struct drm_file *file_priv,
+		  struct drm_device *dev, uint32_t handle, uint64_t *offset);
+
+void evdi_gem_free_object(struct drm_gem_object *gem_obj);
+struct evdi_gem_object *evdi_gem_alloc_object(struct drm_device *dev,
+					      size_t size);
+uint32_t evdi_gem_object_handle_lookup(struct drm_file *filp,
+				      struct drm_gem_object *obj);
+
+struct drm_gem_object *evdi_gem_prime_import(struct drm_device *dev,
+					     struct dma_buf *dma_buf);
+struct dma_buf *evdi_gem_prime_export(struct drm_gem_object *obj, int flags);
+
+int evdi_gem_vmap(struct evdi_gem_object *obj);
+void evdi_gem_vunmap(struct evdi_gem_object *obj);
+int evdi_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
+vm_fault_t evdi_gem_fault(struct vm_fault *vmf);
+void evdi_stats_init(struct evdi_device *evdi);
+void evdi_stats_cleanup(struct evdi_device *evdi);
+
+void evdi_platform_device_unlink_if_linked_with(struct platform_device *pdev,
+				struct device *parent);
+bool evdi_painter_is_connected(struct evdi_device *evdi);
+void evdi_painter_close(struct evdi_device *evdi, struct drm_file *file);
+u8 *evdi_painter_get_edid_copy(struct evdi_device *evdi);
+void evdi_painter_mark_dirty(struct evdi_device *evdi,
+			     const struct drm_clip_rect *rect);
+void evdi_painter_send_update_ready_if_needed(struct evdi_device *evdi);
+void evdi_painter_dpms_notify(struct evdi_device *evdi, int mode);
+void evdi_painter_mode_changed_notify(struct evdi_device *evdi,
+				      struct drm_display_mode *mode);
+void evdi_painter_crtc_state_notify(struct evdi_device *evdi, int state);
+unsigned int evdi_painter_poll(struct file *filp,
+			       struct poll_table_struct *wait);
+
+int evdi_painter_status_ioctl(struct drm_device *drm_dev, void *data,
+			      struct drm_file *file);
+int evdi_painter_connect_ioctl(struct drm_device *drm_dev, void *data,
+			       struct drm_file *file);
+int evdi_painter_grabpix_ioctl(struct drm_device *drm_dev, void *data,
+			       struct drm_file *file);
+int evdi_painter_request_update_ioctl(struct drm_device *drm_dev, void *data,
+				      struct drm_file *file);
+int evdi_painter_ddcci_response_ioctl(struct drm_device *drm_dev, void *data,
+				      struct drm_file *file);
+
+int evdi_painter_init(struct evdi_device *evdi);
+void evdi_painter_cleanup(struct evdi_device *evdi);
+void evdi_painter_set_new_scanout_buffer(struct evdi_device *evdi,
+					 struct evdi_framebuffer *buffer);
+void evdi_painter_commit_scanout_buffer(struct evdi_device *evdi);
+
+struct drm_clip_rect evdi_framebuffer_sanitize_rect(
+			const struct evdi_framebuffer *fb,
+			const struct drm_clip_rect *rect);
+
+int evdi_driver_setup_early(struct drm_device *dev);
+void evdi_driver_setup_late(struct drm_device *dev);
+
+void evdi_painter_send_cursor_set(struct evdi_painter *painter,
+				  struct evdi_cursor *cursor);
+void evdi_painter_send_cursor_move(struct evdi_painter *painter,
+				   struct evdi_cursor *cursor);
+bool evdi_painter_needs_full_modeset(struct evdi_device *evdi);
+struct drm_clip_rect evdi_painter_framebuffer_size(
+			struct evdi_painter *painter);
+bool evdi_painter_i2c_data_notify(struct evdi_device *evdi,
+				struct i2c_msg *msg);
+
+int evdi_fb_get_bpp(uint32_t format);
+#endif
+
diff -ruN a/drivers/gpu/drm/evdi/evdi_encoder.c b/drivers/gpu/drm/evdi/evdi_encoder.c
--- a/drivers/gpu/drm/evdi/evdi_encoder.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_encoder.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2018 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include "evdi_drv.h"
+
+/* dummy encoder */
+static void evdi_enc_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+	kfree(encoder);
+}
+
+static const struct drm_encoder_funcs evdi_enc_funcs = {
+	.destroy = evdi_enc_destroy,
+};
+
+struct drm_encoder *evdi_encoder_init(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+	int ret = 0;
+
+	encoder = kzalloc(sizeof(struct drm_encoder), GFP_KERNEL);
+	if (!encoder)
+		goto err;
+
+	ret = drm_encoder_init(dev, encoder, &evdi_enc_funcs,
+			       DRM_MODE_ENCODER_TMDS, NULL);
+	if (ret) {
+		EVDI_ERROR("Failed to initialize encoder: %d\n", ret);
+		goto err_encoder;
+	}
+
+	encoder->possible_crtcs = 1;
+	return encoder;
+
+err_encoder:
+	kfree(encoder);
+err:
+	return NULL;
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_fb.c b/drivers/gpu/drm/evdi/evdi_fb.c
--- a/drivers/gpu/drm/evdi/evdi_fb.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_fb.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,516 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2018 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/slab.h>
+#ifdef CONFIG_FB
+#include <linux/fb.h>
+#endif /* CONFIG_FB */
+#include <linux/dma-buf.h>
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include "evdi_drv.h"
+
+struct evdi_fbdev {
+	struct drm_fb_helper helper;
+	struct evdi_framebuffer ufb;
+	struct list_head fbdev_list;
+	int fb_count;
+};
+
+struct drm_clip_rect evdi_framebuffer_sanitize_rect(
+				const struct evdi_framebuffer *fb,
+				const struct drm_clip_rect *dirty_rect)
+{
+	struct drm_clip_rect rect = *dirty_rect;
+
+	if (rect.x1 > rect.x2) {
+		unsigned short tmp = rect.x2;
+
+		EVDI_WARN("Wrong clip rect: x1 > x2\n");
+		rect.x2 = rect.x1;
+		rect.x1 = tmp;
+	}
+
+	if (rect.y1 > rect.y2) {
+		unsigned short tmp = rect.y2;
+
+		EVDI_WARN("Wrong clip rect: y1 > y2\n");
+		rect.y2 = rect.y1;
+		rect.y1 = tmp;
+	}
+
+
+	if (rect.x1 > fb->base.width) {
+		EVDI_WARN("Wrong clip rect: x1 > fb.width\n");
+		rect.x1 = fb->base.width;
+	}
+
+	if (rect.y1 > fb->base.height) {
+		EVDI_WARN("Wrong clip rect: y1 > fb.height\n");
+		rect.y1 = fb->base.height;
+	}
+
+	if (rect.x2 > fb->base.width) {
+		EVDI_VERBOSE("Wrong clip rect: x2 > fb.width\n");
+		rect.x2 = fb->base.width;
+	}
+
+	if (rect.y2 > fb->base.height) {
+		EVDI_VERBOSE("Wrong clip rect: y2 > fb.height\n");
+		rect.y2 = fb->base.height;
+	}
+
+	return rect;
+}
+
+static int evdi_handle_damage(struct evdi_framebuffer *fb,
+		       int x, int y, int width, int height)
+{
+	const struct drm_clip_rect dirty_rect = { x, y, x + width, y + height };
+	const struct drm_clip_rect rect =
+		evdi_framebuffer_sanitize_rect(fb, &dirty_rect);
+	struct drm_device *dev = fb->base.dev;
+	struct evdi_device *evdi = dev->dev_private;
+
+	EVDI_CHECKPT();
+
+	if (!fb->active)
+		return 0;
+	evdi_painter_set_new_scanout_buffer(evdi, fb);
+	evdi_painter_commit_scanout_buffer(evdi);
+	evdi_painter_mark_dirty(evdi, &rect);
+
+	return 0;
+}
+
+#ifdef CONFIG_FB
+static int evdi_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	unsigned long start = vma->vm_start;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long page, pos;
+
+	if (offset > info->fix.smem_len ||
+	    size > info->fix.smem_len - offset)
+		return -EINVAL;
+
+	pos = (unsigned long)info->fix.smem_start + offset;
+
+	pr_notice("mmap() framebuffer addr:%lu size:%lu\n", pos, size);
+
+	while (size > 0) {
+		page = vmalloc_to_pfn((void *)pos);
+		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return 0;
+}
+
+static void evdi_fb_fillrect(struct fb_info *info,
+			     const struct fb_fillrect *rect)
+{
+	struct evdi_fbdev *ufbdev = info->par;
+
+	EVDI_CHECKPT();
+	sys_fillrect(info, rect);
+	evdi_handle_damage(&ufbdev->ufb, rect->dx, rect->dy, rect->width,
+			   rect->height);
+}
+
+static void evdi_fb_copyarea(struct fb_info *info,
+			     const struct fb_copyarea *region)
+{
+	struct evdi_fbdev *ufbdev = info->par;
+
+	EVDI_CHECKPT();
+	sys_copyarea(info, region);
+	evdi_handle_damage(&ufbdev->ufb, region->dx, region->dy, region->width,
+			   region->height);
+}
+
+static void evdi_fb_imageblit(struct fb_info *info,
+			      const struct fb_image *image)
+{
+	struct evdi_fbdev *ufbdev = info->par;
+
+	EVDI_CHECKPT();
+	sys_imageblit(info, image);
+	evdi_handle_damage(&ufbdev->ufb, image->dx, image->dy, image->width,
+			   image->height);
+}
+
+/*
+ * It's common for several clients to have framebuffer open simultaneously.
+ * e.g. both fbcon and X. Makes things interesting.
+ * Assumes caller is holding info->lock (for open and release at least)
+ */
+static int evdi_fb_open(struct fb_info *info, int user)
+{
+	struct evdi_fbdev *ufbdev = info->par;
+
+	ufbdev->fb_count++;
+	pr_notice("open /dev/fb%d user=%d fb_info=%p count=%d\n",
+		  info->node, user, info, ufbdev->fb_count);
+
+	return 0;
+}
+
+/*
+ * Assumes caller is holding info->lock mutex (for open and release at least)
+ */
+static int evdi_fb_release(struct fb_info *info, int user)
+{
+	struct evdi_fbdev *ufbdev = info->par;
+
+	ufbdev->fb_count--;
+
+	pr_warn("released /dev/fb%d user=%d count=%d\n",
+		info->node, user, ufbdev->fb_count);
+
+	return 0;
+}
+
+static struct fb_ops evdifb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = drm_fb_helper_check_var,
+	.fb_set_par = drm_fb_helper_set_par,
+	.fb_fillrect = evdi_fb_fillrect,
+	.fb_copyarea = evdi_fb_copyarea,
+	.fb_imageblit = evdi_fb_imageblit,
+	.fb_pan_display = drm_fb_helper_pan_display,
+	.fb_blank = drm_fb_helper_blank,
+	.fb_setcmap = drm_fb_helper_setcmap,
+	.fb_debug_enter = drm_fb_helper_debug_enter,
+	.fb_debug_leave = drm_fb_helper_debug_leave,
+	.fb_mmap = evdi_fb_mmap,
+	.fb_open = evdi_fb_open,
+	.fb_release = evdi_fb_release,
+};
+#endif /* CONFIG_FB */
+
+static int evdi_user_framebuffer_dirty(struct drm_framebuffer *fb,
+				       __always_unused struct drm_file *file,
+				       __always_unused unsigned int flags,
+				       __always_unused unsigned int color,
+				       struct drm_clip_rect *clips,
+				       unsigned int num_clips)
+{
+	struct evdi_framebuffer *ufb = to_evdi_fb(fb);
+	struct drm_device *dev = ufb->base.dev;
+	struct evdi_device *evdi = dev->dev_private;
+	int i;
+	int ret = 0;
+
+	EVDI_CHECKPT();
+	drm_modeset_lock_all(fb->dev);
+
+	if (!ufb->active)
+		goto unlock;
+
+	if (ufb->obj->base.import_attach) {
+		ret =
+		    dma_buf_begin_cpu_access(
+			ufb->obj->base.import_attach->dmabuf,
+			DMA_FROM_DEVICE);
+		if (ret)
+			goto unlock;
+	}
+
+	for (i = 0; i < num_clips; i++) {
+		ret = evdi_handle_damage(ufb, clips[i].x1, clips[i].y1,
+					 clips[i].x2 - clips[i].x1,
+					 clips[i].y2 - clips[i].y1);
+		if (ret)
+			goto unlock;
+	}
+
+	if (ufb->obj->base.import_attach)
+		dma_buf_end_cpu_access(ufb->obj->base.import_attach->dmabuf,
+				       DMA_FROM_DEVICE);
+	atomic_add(1, &evdi->frame_count);
+ unlock:
+	drm_modeset_unlock_all(fb->dev);
+	return ret;
+}
+
+static int evdi_user_framebuffer_create_handle(struct drm_framebuffer *fb,
+					       struct drm_file *file_priv,
+					       unsigned int *handle)
+{
+	struct evdi_framebuffer *efb = to_evdi_fb(fb);
+
+	return drm_gem_handle_create(file_priv, &efb->obj->base, handle);
+}
+
+static void evdi_user_framebuffer_destroy(struct drm_framebuffer *fb)
+{
+	struct evdi_framebuffer *ufb = to_evdi_fb(fb);
+
+	EVDI_CHECKPT();
+
+	if (ufb->obj)
+		drm_gem_object_put(&ufb->obj->base);
+
+	drm_framebuffer_cleanup(fb);
+	kfree(ufb);
+}
+
+static const struct drm_framebuffer_funcs evdifb_funcs = {
+	.create_handle = evdi_user_framebuffer_create_handle,
+	.destroy = evdi_user_framebuffer_destroy,
+	.dirty = evdi_user_framebuffer_dirty,
+};
+
+static int
+evdi_framebuffer_init(struct drm_device *dev,
+		      struct evdi_framebuffer *ufb,
+		      const struct drm_mode_fb_cmd2 *mode_cmd,
+		      struct evdi_gem_object *obj)
+{
+	ufb->obj = obj;
+	drm_helper_mode_fill_fb_struct(dev, &ufb->base, mode_cmd);
+	return drm_framebuffer_init(dev, &ufb->base, &evdifb_funcs);
+}
+
+#ifdef CONFIG_FB
+static int evdifb_create(struct drm_fb_helper *helper,
+			 struct drm_fb_helper_surface_size *sizes)
+{
+	struct evdi_fbdev *ufbdev = (struct evdi_fbdev *)helper;
+	struct drm_device *dev = ufbdev->helper.dev;
+	struct fb_info *info;
+	struct device *device = dev->dev;
+	struct drm_framebuffer *fb;
+	struct drm_mode_fb_cmd2 mode_cmd;
+	struct evdi_gem_object *obj;
+	uint32_t size;
+	int ret = 0;
+
+	if (sizes->surface_bpp == 24) {
+		sizes->surface_bpp = 32;
+	} else if (sizes->surface_bpp != 32) {
+		EVDI_ERROR("Not supported pixel format (bpp=%d)\n",
+			   sizes->surface_bpp);
+		return -EINVAL;
+	}
+
+	mode_cmd.width = sizes->surface_width;
+	mode_cmd.height = sizes->surface_height;
+	mode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);
+
+	mode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,
+							  sizes->surface_depth);
+
+	size = mode_cmd.pitches[0] * mode_cmd.height;
+	size = ALIGN(size, PAGE_SIZE);
+
+	obj = evdi_gem_alloc_object(dev, size);
+	if (!obj)
+		goto out;
+
+	ret = evdi_gem_vmap(obj);
+	if (ret) {
+		DRM_ERROR("failed to vmap fb\n");
+		goto out_gfree;
+	}
+
+	info = framebuffer_alloc(0, device);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out_gfree;
+	}
+
+	ret = evdi_framebuffer_init(dev, &ufbdev->ufb, &mode_cmd, obj);
+	if (ret)
+		goto out_gfree;
+
+	fb = &ufbdev->ufb.base;
+
+	ufbdev->helper.fb = fb;
+	ufbdev->helper.fbdev = info;
+
+	info->screen_base = ufbdev->ufb.obj->vmapping;
+	info->fix.smem_len = size;
+	info->fix.smem_start = (unsigned long)ufbdev->ufb.obj->vmapping;
+
+	info->flags = FBINFO_DEFAULT;
+	info->fbops = &evdifb_ops;
+
+	drm_fb_helper_fill_info(info, helper, sizes);
+
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		ret = -ENOMEM;
+		goto out_gfree;
+	}
+
+	DRM_DEBUG_KMS("allocated %dx%d vmal %p\n",
+		      fb->width, fb->height, ufbdev->ufb.obj->vmapping);
+
+	return ret;
+ out_gfree:
+	drm_gem_object_put(&ufbdev->ufb.obj->base);
+ out:
+	return ret;
+}
+
+static struct drm_fb_helper_funcs evdi_fb_helper_funcs = {
+	.fb_probe = evdifb_create,
+};
+
+static void evdi_fbdev_destroy(__always_unused struct drm_device *dev,
+			       struct evdi_fbdev *ufbdev)
+{
+	struct fb_info *info;
+
+	if (ufbdev->helper.fbdev) {
+		info = ufbdev->helper.fbdev;
+		unregister_framebuffer(info);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
+
+		framebuffer_release(info);
+	}
+	drm_fb_helper_fini(&ufbdev->helper);
+	drm_framebuffer_unregister_private(&ufbdev->ufb.base);
+	drm_framebuffer_cleanup(&ufbdev->ufb.base);
+	drm_gem_object_put(&ufbdev->ufb.obj->base);
+}
+
+int evdi_fbdev_init(struct drm_device *dev)
+{
+	struct evdi_device *evdi;
+	struct evdi_fbdev *ufbdev;
+	int ret;
+
+	evdi = dev->dev_private;
+	ufbdev = kzalloc(sizeof(struct evdi_fbdev), GFP_KERNEL);
+	if (!ufbdev)
+		return -ENOMEM;
+
+	evdi->fbdev = ufbdev;
+	drm_fb_helper_prepare(dev, &ufbdev->helper, &evdi_fb_helper_funcs);
+
+	ret = drm_fb_helper_init(dev, &ufbdev->helper, 1);
+	if (ret) {
+		kfree(ufbdev);
+		return ret;
+	}
+
+	ret = drm_fb_helper_initial_config(&ufbdev->helper, 32);
+	if (ret) {
+		drm_fb_helper_fini(&ufbdev->helper);
+		kfree(ufbdev);
+	}
+	return ret;
+}
+
+void evdi_fbdev_cleanup(struct drm_device *dev)
+{
+	struct evdi_device *evdi = dev->dev_private;
+
+	if (!evdi->fbdev)
+		return;
+
+	evdi_fbdev_destroy(dev, evdi->fbdev);
+	kfree(evdi->fbdev);
+	evdi->fbdev = NULL;
+}
+
+void evdi_fbdev_unplug(struct drm_device *dev)
+{
+	struct evdi_device *evdi = dev->dev_private;
+	struct evdi_fbdev *ufbdev;
+
+	if (!evdi->fbdev)
+		return;
+
+	ufbdev = evdi->fbdev;
+	if (ufbdev->helper.fbdev) {
+		struct fb_info *info;
+
+		info = ufbdev->helper.fbdev;
+		unlink_framebuffer(info);
+	}
+}
+#endif /* CONFIG_FB */
+
+int evdi_fb_get_bpp(uint32_t format)
+{
+	const struct drm_format_info *info;
+
+	info = drm_format_info(format);
+	if (info && info->depth)
+		return info->cpp[0] * 8;
+	return 0;
+}
+
+struct drm_framebuffer *evdi_fb_user_fb_create(
+					struct drm_device *dev,
+					struct drm_file *file,
+					const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct drm_gem_object *obj;
+	struct evdi_framebuffer *ufb;
+	int ret;
+	uint32_t size;
+
+	int bpp = evdi_fb_get_bpp(mode_cmd->pixel_format);
+
+	if (bpp != 32) {
+		EVDI_ERROR("Unsupported bpp (%d)\n", bpp);
+		return ERR_PTR(-EINVAL);
+	}
+
+	obj = drm_gem_object_lookup(file, mode_cmd->handles[0]);
+	if (obj == NULL)
+		return ERR_PTR(-ENOENT);
+
+	size = mode_cmd->pitches[0] * mode_cmd->height;
+	size = ALIGN(size, PAGE_SIZE);
+
+	if (size > obj->size) {
+		DRM_ERROR("object size not sufficient for fb %d %zu %d %d\n",
+			  size, obj->size, mode_cmd->pitches[0],
+			  mode_cmd->height);
+		goto err_no_mem;
+	}
+
+	ufb = kzalloc(sizeof(*ufb), GFP_KERNEL);
+	if (ufb == NULL)
+		goto err_no_mem;
+
+	ret = evdi_framebuffer_init(dev, ufb, mode_cmd, to_evdi_bo(obj));
+	if (ret)
+		goto err_inval;
+	return &ufb->base;
+
+ err_no_mem:
+	drm_gem_object_put(obj);
+	return ERR_PTR(-ENOMEM);
+ err_inval:
+	kfree(ufb);
+	drm_gem_object_put(obj);
+	return ERR_PTR(-EINVAL);
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_gem.c b/drivers/gpu/drm/evdi/evdi_gem.c
--- a/drivers/gpu/drm/evdi/evdi_gem.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_gem.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,524 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2018 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <drm/drmP.h>
+#include "evdi_drv.h"
+#include <linux/shmem_fs.h>
+#include <linux/dma-buf.h>
+
+uint32_t evdi_gem_object_handle_lookup(struct drm_file *filp,
+				       struct drm_gem_object *obj)
+{
+	uint32_t it_handle = 0;
+	struct drm_gem_object *it_obj = NULL;
+
+	spin_lock(&filp->table_lock);
+	idr_for_each_entry(&filp->object_idr, it_obj, it_handle) {
+		if (it_obj == obj)
+			break;
+	}
+	spin_unlock(&filp->table_lock);
+
+	if (!it_obj)
+		it_handle = 0;
+
+	return it_handle;
+}
+
+struct evdi_gem_object *evdi_gem_alloc_object(struct drm_device *dev,
+					      size_t size)
+{
+	struct evdi_gem_object *obj;
+
+	obj = kzalloc(sizeof(*obj), GFP_KERNEL);
+	if (obj == NULL)
+		return NULL;
+
+	if (drm_gem_object_init(dev, &obj->base, size) != 0) {
+		kfree(obj);
+		return NULL;
+	}
+
+	dma_resv_init(&obj->_resv);
+	obj->resv = &obj->_resv;
+
+	return obj;
+}
+
+static int
+evdi_gem_create(struct drm_file *file,
+		struct drm_device *dev, uint64_t size, uint32_t *handle_p)
+{
+	struct evdi_gem_object *obj;
+	int ret;
+	u32 handle;
+
+	size = roundup(size, PAGE_SIZE);
+
+	obj = evdi_gem_alloc_object(dev, size);
+	if (obj == NULL)
+		return -ENOMEM;
+
+	ret = drm_gem_handle_create(file, &obj->base, &handle);
+	if (ret) {
+		drm_gem_object_release(&obj->base);
+		kfree(obj);
+		return ret;
+	}
+
+	drm_gem_object_put(&obj->base);
+	*handle_p = handle;
+	return 0;
+}
+
+static int evdi_align_pitch(int width, int cpp)
+{
+	int aligned = width;
+	int pitch_mask = 0;
+
+	switch (cpp) {
+	case 1:
+		pitch_mask = 255;
+		break;
+	case 2:
+		pitch_mask = 127;
+		break;
+	case 3:
+	case 4:
+		pitch_mask = 63;
+		break;
+	}
+
+	aligned += pitch_mask;
+	aligned &= ~pitch_mask;
+	return aligned * cpp;
+}
+
+int evdi_dumb_create(struct drm_file *file,
+		     struct drm_device *dev, struct drm_mode_create_dumb *args)
+{
+	args->pitch = evdi_align_pitch(args->width, DIV_ROUND_UP(args->bpp, 8));
+	args->size = args->pitch * args->height;
+	return evdi_gem_create(file, dev, args->size, &args->handle);
+}
+
+int evdi_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+
+	ret = drm_gem_mmap(filp, vma);
+	if (ret)
+		return ret;
+
+	vma->vm_flags &= ~VM_PFNMAP;
+	vma->vm_flags |= VM_MIXEDMAP;
+
+	return ret;
+}
+
+vm_fault_t evdi_gem_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+	struct evdi_gem_object *obj = to_evdi_bo(vma->vm_private_data);
+	struct page *page;
+	unsigned int page_offset;
+	int ret = 0;
+
+	page_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;
+
+	if (!obj->pages)
+		return VM_FAULT_SIGBUS;
+
+	page = obj->pages[page_offset];
+	ret = vm_insert_page(vma, (unsigned long)vmf->address, page);
+	switch (ret) {
+	case -EAGAIN:
+	case 0:
+	case -ERESTARTSYS:
+		return VM_FAULT_NOPAGE;
+	case -ENOMEM:
+		return VM_FAULT_OOM;
+	default:
+		return VM_FAULT_SIGBUS;
+	}
+	return VM_FAULT_SIGBUS;
+}
+
+static int evdi_gem_get_pages(struct evdi_gem_object *obj)
+{
+	struct page **pages;
+
+	if (obj->pages)
+		return 0;
+
+	pages = drm_gem_get_pages(&obj->base);
+	if (IS_ERR(pages))
+		return PTR_ERR(pages);
+
+	obj->pages = pages;
+
+#if defined(CONFIG_X86)
+	drm_clflush_pages(obj->pages, obj->base.size / PAGE_SIZE);
+#endif
+
+	return 0;
+}
+
+static void evdi_gem_put_pages(struct evdi_gem_object *obj)
+{
+	if (obj->base.import_attach) {
+		kvfree(obj->pages);
+		obj->pages = NULL;
+		return;
+	}
+	if (obj->pages)
+		drm_gem_put_pages(&obj->base, obj->pages, false, false);
+	obj->pages = NULL;
+}
+
+int evdi_gem_vmap(struct evdi_gem_object *obj)
+{
+	int page_count = obj->base.size / PAGE_SIZE;
+	int ret;
+
+	if (obj->base.import_attach) {
+		obj->vmapping = dma_buf_vmap(obj->base.import_attach->dmabuf);
+		if (!obj->vmapping)
+			return -ENOMEM;
+		return 0;
+	}
+
+	ret = evdi_gem_get_pages(obj);
+	if (ret)
+		return ret;
+
+	obj->vmapping = vmap(obj->pages, page_count, 0, PAGE_KERNEL);
+	if (!obj->vmapping)
+		return -ENOMEM;
+	return 0;
+}
+
+void evdi_gem_vunmap(struct evdi_gem_object *obj)
+{
+	if (obj->base.import_attach) {
+		dma_buf_vunmap(obj->base.import_attach->dmabuf, obj->vmapping);
+		obj->vmapping = NULL;
+		return;
+	}
+
+	if (obj->vmapping) {
+		vunmap(obj->vmapping);
+		obj->vmapping = NULL;
+	}
+
+	evdi_gem_put_pages(obj);
+}
+
+void evdi_gem_free_object(struct drm_gem_object *gem_obj)
+{
+	struct evdi_gem_object *obj = to_evdi_bo(gem_obj);
+
+	if (obj->vmapping)
+		evdi_gem_vunmap(obj);
+
+	if (gem_obj->import_attach) {
+		drm_prime_gem_destroy(gem_obj, obj->sg);
+		put_device(gem_obj->dev->dev);
+	}
+
+	if (obj->pages)
+		evdi_gem_put_pages(obj);
+
+	if (gem_obj->dev->vma_offset_manager)
+		drm_gem_free_mmap_offset(gem_obj);
+
+	dma_resv_init(&obj->_resv);
+	obj->resv = NULL;
+}
+
+/*
+ * the dumb interface doesn't work with the GEM straight MMAP
+ * interface, it expects to do MMAP on the drm fd, like normal
+ */
+int evdi_gem_mmap(struct drm_file *file,
+		  struct drm_device *dev, uint32_t handle, uint64_t *offset)
+{
+	struct evdi_gem_object *gobj;
+	struct drm_gem_object *obj;
+	int ret = 0;
+
+	mutex_lock(&dev->struct_mutex);
+	obj = drm_gem_object_lookup(file, handle);
+	if (obj == NULL) {
+		ret = -ENOENT;
+		goto unlock;
+	}
+	gobj = to_evdi_bo(obj);
+
+	ret = evdi_gem_get_pages(gobj);
+	if (ret)
+		goto out;
+
+	ret = drm_gem_create_mmap_offset(obj);
+	if (ret)
+		goto out;
+
+	*offset = drm_vma_node_offset_addr(&gobj->base.vma_node);
+
+ out:
+	drm_gem_object_put(&gobj->base);
+ unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+static int evdi_prime_create(struct drm_device *dev,
+			     size_t size,
+			     struct sg_table *sg,
+			     struct evdi_gem_object **obj_p)
+{
+	struct evdi_gem_object *obj;
+	int npages;
+
+	npages = size / PAGE_SIZE;
+
+	*obj_p = NULL;
+	obj = evdi_gem_alloc_object(dev, npages * PAGE_SIZE);
+	if (!obj)
+		return -ENOMEM;
+
+	obj->sg = sg;
+	obj->pages = kvmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);
+	if (obj->pages == NULL) {
+		DRM_ERROR("obj pages is NULL %d\n", npages);
+		return -ENOMEM;
+	}
+
+	drm_prime_sg_to_page_addr_arrays(sg, obj->pages, NULL, npages);
+
+	*obj_p = obj;
+	return 0;
+}
+
+struct evdi_drm_dmabuf_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dir;
+	bool is_mapped;
+};
+
+static int evdi_attach_dma_buf(__always_unused struct dma_buf *dmabuf,
+			       struct dma_buf_attachment *attach)
+{
+	struct evdi_drm_dmabuf_attachment *evdi_attach;
+
+	evdi_attach = kzalloc(sizeof(*evdi_attach), GFP_KERNEL);
+	if (!evdi_attach)
+		return -ENOMEM;
+
+	evdi_attach->dir = DMA_NONE;
+	attach->priv = evdi_attach;
+
+	return 0;
+}
+
+static void evdi_detach_dma_buf(__always_unused struct dma_buf *dmabuf,
+				struct dma_buf_attachment *attach)
+{
+	struct evdi_drm_dmabuf_attachment *evdi_attach = attach->priv;
+	struct sg_table *sgt;
+
+	if (!evdi_attach)
+		return;
+
+	sgt = &evdi_attach->sgt;
+
+	if (evdi_attach->dir != DMA_NONE)
+		dma_unmap_sg(attach->dev, sgt->sgl, sgt->nents,
+			     evdi_attach->dir);
+
+	sg_free_table(sgt);
+	kfree(evdi_attach);
+	attach->priv = NULL;
+}
+
+static struct sg_table *evdi_map_dma_buf(struct dma_buf_attachment *attach,
+					 enum dma_data_direction dir)
+{
+	struct evdi_drm_dmabuf_attachment *evdi_attach = attach->priv;
+	struct evdi_gem_object *obj = to_evdi_bo(attach->dmabuf->priv);
+	struct drm_device *dev = obj->base.dev;
+	struct scatterlist *rd, *wr;
+	struct sg_table *sgt = NULL;
+	unsigned int i;
+	int page_count;
+	int nents, ret;
+
+	DRM_DEBUG_PRIME("[DEV:%s] size:%zd dir=%d\n", dev_name(attach->dev),
+			attach->dmabuf->size, dir);
+
+	/* just return current sgt if already requested. */
+	if (evdi_attach->dir == dir && evdi_attach->is_mapped)
+		return &evdi_attach->sgt;
+
+	if (!obj->pages) {
+		ret = evdi_gem_get_pages(obj);
+		if (ret) {
+			DRM_ERROR("failed to map pages.\n");
+			return ERR_PTR(ret);
+		}
+	}
+
+	page_count = obj->base.size / PAGE_SIZE;
+	obj->sg = drm_prime_pages_to_sg(obj->pages, page_count);
+	if (IS_ERR(obj->sg)) {
+		DRM_ERROR("failed to allocate sgt.\n");
+		return ERR_CAST(obj->sg);
+	}
+
+	sgt = &evdi_attach->sgt;
+
+	ret = sg_alloc_table(sgt, obj->sg->orig_nents, GFP_KERNEL);
+	if (ret) {
+		DRM_ERROR("failed to alloc sgt.\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	mutex_lock(&dev->struct_mutex);
+
+	rd = obj->sg->sgl;
+	wr = sgt->sgl;
+	for (i = 0; i < sgt->orig_nents; ++i) {
+		sg_set_page(wr, sg_page(rd), rd->length, rd->offset);
+		rd = sg_next(rd);
+		wr = sg_next(wr);
+	}
+
+	if (dir != DMA_NONE) {
+		nents = dma_map_sg(attach->dev, sgt->sgl, sgt->orig_nents, dir);
+		if (!nents) {
+			DRM_ERROR("failed to map sgl with iommu.\n");
+			sg_free_table(sgt);
+			sgt = ERR_PTR(-EIO);
+			goto err_unlock;
+		}
+	}
+
+	evdi_attach->is_mapped = true;
+	evdi_attach->dir = dir;
+	attach->priv = evdi_attach;
+
+ err_unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return sgt;
+}
+
+static void evdi_unmap_dma_buf(
+			__always_unused struct dma_buf_attachment *attach,
+			__always_unused struct sg_table *sgt,
+			__always_unused enum dma_data_direction dir)
+{
+}
+
+static void *evdi_dmabuf_kmap(__always_unused struct dma_buf *dma_buf,
+			__always_unused unsigned long page_num)
+{
+	return NULL;
+}
+
+static void evdi_dmabuf_kunmap(
+			__always_unused struct dma_buf *dma_buf,
+			__always_unused unsigned long page_num,
+			__always_unused void *addr)
+{
+}
+
+static int evdi_dmabuf_mmap(__always_unused struct dma_buf *dma_buf,
+			__always_unused struct vm_area_struct *vma)
+{
+	return -EINVAL;
+}
+
+static struct dma_buf_ops evdi_dmabuf_ops = {
+
+	.attach = evdi_attach_dma_buf,
+	.detach = evdi_detach_dma_buf,
+	.map_dma_buf = evdi_map_dma_buf,
+	.unmap_dma_buf = evdi_unmap_dma_buf,
+	.map = evdi_dmabuf_kmap,
+	.unmap = evdi_dmabuf_kunmap,
+	.mmap = evdi_dmabuf_mmap,
+	.release = drm_gem_dmabuf_release,
+};
+
+struct drm_gem_object *evdi_gem_prime_import(struct drm_device *dev,
+					     struct dma_buf *dma_buf)
+{
+	struct dma_buf_attachment *attach;
+	struct sg_table *sg;
+	struct evdi_gem_object *uobj;
+	int ret;
+
+	/* check if our object */
+	if (dma_buf->ops == &evdi_dmabuf_ops) {
+		uobj = to_evdi_bo(dma_buf->priv);
+		if (uobj->base.dev == dev) {
+			drm_gem_object_get(&uobj->base);
+			return &uobj->base;
+		}
+	}
+
+	/* need to attach */
+	get_device(dev->dev);
+	attach = dma_buf_attach(dma_buf, dev->dev);
+	if (IS_ERR(attach)) {
+		put_device(dev->dev);
+		return ERR_CAST(attach);
+	}
+
+	get_dma_buf(dma_buf);
+
+	sg = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR(sg)) {
+		ret = PTR_ERR(sg);
+		goto fail_detach;
+	}
+
+	ret = evdi_prime_create(dev, dma_buf->size, sg, &uobj);
+	if (ret)
+		goto fail_unmap;
+
+	uobj->base.import_attach = attach;
+	uobj->resv = attach->dmabuf->resv;
+
+	return &uobj->base;
+
+ fail_unmap:
+	dma_buf_unmap_attachment(attach, sg, DMA_BIDIRECTIONAL);
+ fail_detach:
+	dma_buf_detach(dma_buf, attach);
+	dma_buf_put(dma_buf);
+	put_device(dev->dev);
+	return ERR_PTR(ret);
+}
+
+struct dma_buf *evdi_gem_prime_export(struct drm_gem_object *obj, int flags)
+{
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+	struct evdi_gem_object *evdi_obj = to_evdi_bo(obj);
+
+	exp_info.exp_name = "evdi",
+	exp_info.ops = &evdi_dmabuf_ops,
+	exp_info.size = obj->size,
+	exp_info.flags = flags,
+	exp_info.resv = evdi_obj->resv,
+	exp_info.priv = obj;
+
+	return drm_gem_dmabuf_export(obj->dev, &exp_info);
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_i2c.c b/drivers/gpu/drm/evdi/evdi_i2c.c
--- a/drivers/gpu/drm/evdi/evdi_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_i2c.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include "evdi_i2c.h"
+#include "evdi_debug.h"
+#include "evdi_drv.h"
+
+static int dli2c_access_master(struct i2c_adapter *adapter,
+	struct i2c_msg *msgs, int num)
+{
+	int i = 0, result = 0;
+	struct evdi_device *evdi = adapter->algo_data;
+
+	for (i = 0; i < num; i++) {
+		if (evdi_painter_i2c_data_notify(evdi, &msgs[i]))
+			result++;
+	}
+
+	return result;
+}
+
+static u32 dli2c_func(__always_unused struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm dli2c_algorithm = {
+	.master_xfer = dli2c_access_master,
+	.functionality = dli2c_func,
+};
+
+int evdi_i2c_add(struct i2c_adapter *adapter, struct device *parent,
+	void *ddev)
+{
+	adapter->owner  = THIS_MODULE;
+	adapter->class  = I2C_CLASS_DDC;
+	adapter->algo   = &dli2c_algorithm;
+	strcpy(adapter->name, "DisplayLink I2C Adapter");
+	adapter->dev.parent = parent;
+	adapter->algo_data = ddev;
+
+	return i2c_add_adapter(adapter);
+}
+
+void evdi_i2c_remove(struct i2c_adapter *adapter)
+{
+	i2c_del_adapter(adapter);
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_i2c.h b/drivers/gpu/drm/evdi/evdi_i2c.h
--- a/drivers/gpu/drm/evdi/evdi_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_i2c.h	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_I2C_H
+#define EVDI_I2C_H
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+
+int evdi_i2c_add(struct i2c_adapter *adapter,
+		struct device *parent,
+		void *ddev);
+void evdi_i2c_remove(struct i2c_adapter *adapter);
+
+#endif  /* EVDI_I2C_H */
diff -ruN a/drivers/gpu/drm/evdi/evdi_ioc32.c b/drivers/gpu/drm/evdi/evdi_ioc32.c
--- a/drivers/gpu/drm/evdi/evdi_ioc32.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_ioc32.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/**
+ * evdi_ioc32.c
+ *
+ * Copyright (c) 2016 The Chromium OS Authors
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/compat.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_edid.h>
+#include <uapi/drm/evdi_drm.h>
+
+#include "evdi_drv.h"
+
+struct drm_evdi_connect32 {
+	int32_t connected;
+	int32_t dev_index;
+	uint32_t edid_ptr32;
+	uint32_t edid_length;
+	uint32_t sku_area_limit;
+};
+
+struct drm_evdi_grabpix32 {
+	uint32_t mode;
+	int32_t buf_width;
+	int32_t buf_height;
+	int32_t buf_byte_stride;
+	uint32_t buffer_ptr32;
+	int32_t num_rects;
+	uint32_t rects_ptr32;
+};
+
+static int compat_evdi_connect(struct file *file,
+				unsigned int __always_unused cmd,
+				unsigned long arg)
+{
+	struct drm_evdi_connect32 req32;
+	struct drm_evdi_connect __user *request;
+
+	if (copy_from_user(&req32, (void __user *)arg, sizeof(req32)))
+		return -EFAULT;
+
+	request = compat_alloc_user_space(sizeof(*request));
+	if (!access_ok(request, sizeof(*request))
+	    || __put_user(req32.connected, &request->connected)
+	    || __put_user(req32.dev_index, &request->dev_index)
+	    || __put_user((void __user *)(unsigned long)req32.edid_ptr32,
+			  &request->edid)
+	    || __put_user(req32.edid_length, &request->edid_length)
+	    || __put_user(req32.sku_area_limit, &request->sku_area_limit))
+		return -EFAULT;
+
+	return drm_ioctl(file, DRM_IOCTL_EVDI_CONNECT,
+			 (unsigned long)request);
+}
+
+static int compat_evdi_grabpix(struct file *file,
+				unsigned int __always_unused cmd,
+				unsigned long arg)
+{
+	struct drm_evdi_grabpix32 req32;
+	struct drm_evdi_grabpix __user *request;
+
+	if (copy_from_user(&req32, (void __user *)arg, sizeof(req32)))
+		return -EFAULT;
+
+	request = compat_alloc_user_space(sizeof(*request));
+	if (!access_ok(request, sizeof(*request))
+	    || __put_user(req32.mode, &request->mode)
+	    || __put_user(req32.buf_width, &request->buf_width)
+	    || __put_user(req32.buf_height, &request->buf_height)
+	    || __put_user(req32.buf_byte_stride, &request->buf_byte_stride)
+	    || __put_user((void __user *)(unsigned long)req32.buffer_ptr32,
+			  &request->buffer)
+	    || __put_user(req32.num_rects, &request->num_rects)
+	    || __put_user((void __user *)(unsigned long)req32.rects_ptr32,
+			  &request->rects))
+		return -EFAULT;
+
+	return drm_ioctl(file, DRM_IOCTL_EVDI_GRABPIX,
+			 (unsigned long)request);
+}
+
+static drm_ioctl_compat_t *evdi_compat_ioctls[] = {
+	[DRM_EVDI_CONNECT] = compat_evdi_connect,
+	[DRM_EVDI_GRABPIX] = compat_evdi_grabpix,
+};
+
+/**
+ * Called whenever a 32-bit process running under a 64-bit kernel
+ * performs an ioctl on /dev/dri/card<n>.
+ *
+ * \param filp file pointer.
+ * \param cmd command.
+ * \param arg user argument.
+ * \return zero on success or negative number on failure.
+ */
+long evdi_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned int nr = DRM_IOCTL_NR(cmd);
+	drm_ioctl_compat_t *fn = NULL;
+	int ret;
+
+	if (nr < DRM_COMMAND_BASE || nr >= DRM_COMMAND_END)
+		return drm_compat_ioctl(filp, cmd, arg);
+
+	if (nr < DRM_COMMAND_BASE + ARRAY_SIZE(evdi_compat_ioctls))
+		fn = evdi_compat_ioctls[nr - DRM_COMMAND_BASE];
+
+	if (fn != NULL)
+		ret = (*fn) (filp, cmd, arg);
+	else
+		ret = drm_ioctl(filp, cmd, arg);
+
+	return ret;
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_main.c b/drivers/gpu/drm/evdi/evdi_main.c
--- a/drivers/gpu/drm/evdi/evdi_main.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_main.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2018 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/platform_device.h>
+#include <drm/drmP.h>
+#include <drm/drm_probe_helper.h>
+#include "evdi_drv.h"
+#include "evdi_cursor.h"
+
+int evdi_driver_load(struct drm_device *dev,
+		     __always_unused unsigned long flags)
+{
+	struct platform_device *platdev = NULL;
+	struct evdi_device *evdi;
+	int ret;
+
+	EVDI_CHECKPT();
+	evdi = kzalloc(sizeof(struct evdi_device), GFP_KERNEL);
+	if (!evdi)
+		return -ENOMEM;
+
+	evdi->ddev = dev;
+	dev->dev_private = evdi;
+
+	ret =  evdi_cursor_init(&evdi->cursor);
+	if (ret)
+		goto err;
+
+	EVDI_CHECKPT();
+	evdi_modeset_init(dev);
+
+#ifdef CONFIG_FB
+	ret = evdi_fbdev_init(dev);
+	if (ret)
+		goto err;
+#endif /* CONFIG_FB */
+
+	ret = drm_vblank_init(dev, 1);
+	if (ret)
+		goto err_fb;
+
+	ret = evdi_painter_init(evdi);
+	if (ret)
+		goto err_fb;
+
+	evdi_stats_init(evdi);
+
+	drm_kms_helper_poll_init(dev);
+
+	platdev = to_platform_device(dev->dev);
+	platform_set_drvdata(platdev, dev);
+
+	return 0;
+
+err_fb:
+#ifdef CONFIG_FB
+	evdi_fbdev_cleanup(dev);
+#endif /* CONFIG_FB */
+err:
+	kfree(evdi);
+	EVDI_ERROR("%d\n", ret);
+	if (evdi->cursor)
+		evdi_cursor_free(evdi->cursor);
+	return ret;
+}
+
+void evdi_driver_setup_late(struct drm_device *dev)
+{
+	evdi_stats_init(dev->dev_private);
+}
+
+void evdi_driver_unload(struct drm_device *dev)
+{
+	struct evdi_device *evdi = dev->dev_private;
+
+	EVDI_CHECKPT();
+
+	drm_kms_helper_poll_fini(dev);
+#ifdef CONFIG_FB
+	evdi_fbdev_unplug(dev);
+#endif /* CONFIG_FB */
+
+	if (evdi->cursor)
+		evdi_cursor_free(evdi->cursor);
+	evdi_painter_cleanup(evdi);
+	evdi_stats_cleanup(evdi);
+#ifdef CONFIG_FB
+	evdi_fbdev_cleanup(dev);
+#endif /* CONFIG_FB */
+	evdi_modeset_cleanup(dev);
+
+	kfree(evdi);
+}
+
+void evdi_driver_preclose(struct drm_device *drm_dev, struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+
+	EVDI_CHECKPT();
+	if (evdi)
+		evdi_painter_close(evdi, file);
+}
+
diff -ruN a/drivers/gpu/drm/evdi/evdi_modeset.c b/drivers/gpu/drm/evdi/evdi_modeset.c
--- a/drivers/gpu/drm/evdi/evdi_modeset.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_modeset.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2019 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <uapi/drm/evdi_drm.h>
+#include "evdi_drv.h"
+#include "evdi_cursor.h"
+
+static void evdi_crtc_dpms(
+			__always_unused struct drm_crtc *crtc,
+			__always_unused int mode)
+{
+	EVDI_CHECKPT();
+}
+
+static void evdi_crtc_destroy(struct drm_crtc *crtc)
+{
+	EVDI_CHECKPT();
+	drm_crtc_cleanup(crtc);
+	kfree(crtc);
+}
+
+static void evdi_crtc_commit(__always_unused struct drm_crtc *crtc)
+{
+	EVDI_CHECKPT();
+}
+
+static void evdi_crtc_atomic_flush(
+			struct drm_crtc *crtc,
+			__always_unused struct drm_crtc_state *old_state)
+{
+	struct drm_crtc_state *state = crtc->state;
+	struct evdi_device *evdi = crtc->dev->dev_private;
+	unsigned long flags;
+
+	if (state->event) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		drm_crtc_send_vblank_event(crtc, state->event);
+		state->event = NULL;
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+	}
+	if (state->mode_changed && state->active)
+		evdi_painter_mode_changed_notify(evdi, &state->adjusted_mode);
+
+	if (state->active_changed)
+		evdi_painter_dpms_notify(evdi,
+			state->active ? DRM_MODE_DPMS_ON : DRM_MODE_DPMS_OFF);
+
+	evdi_painter_send_update_ready_if_needed(evdi);
+}
+
+static void evdi_mark_full_screen_dirty(struct evdi_device *evdi)
+{
+	const struct drm_clip_rect rect =
+		evdi_painter_framebuffer_size(evdi->painter);
+
+	evdi_painter_mark_dirty(evdi, &rect);
+	evdi_painter_send_update_ready_if_needed(evdi);
+}
+
+static int evdi_crtc_cursor_set(struct drm_crtc *crtc,
+				struct drm_file *file,
+				uint32_t handle,
+				uint32_t width,
+				uint32_t height,
+				int32_t hot_x,
+				int32_t hot_y)
+{
+	struct drm_device *dev = crtc->dev;
+	struct evdi_device *evdi = dev->dev_private;
+	struct drm_gem_object *obj = NULL;
+	struct evdi_gem_object *eobj = NULL;
+	/*
+	 * evdi_crtc_cursor_set is callback function using
+	 * deprecated cursor entry point.
+	 * There is no info about underlaying pixel format.
+	 * Hence we are assuming that it is in ARGB 32bpp format.
+	 * This format it the only one supported in cursor composition
+	 * function.
+	 * This format is also enforced during framebuffer creation.
+	 *
+	 * Proper format will be available when driver start support
+	 * universal planes for cursor.
+	 */
+	uint32_t format = DRM_FORMAT_ARGB8888;
+	uint32_t stride = 4 * width;
+
+	EVDI_CHECKPT();
+	if (handle) {
+		mutex_lock(&dev->struct_mutex);
+		obj = drm_gem_object_lookup(file, handle);
+		if (obj)
+			eobj = to_evdi_bo(obj);
+		else
+			EVDI_ERROR("Failed to lookup gem object.\n");
+		mutex_unlock(&dev->struct_mutex);
+	}
+
+	evdi_cursor_set(evdi->cursor,
+			eobj, width, height, hot_x, hot_y,
+			format, stride);
+	drm_gem_object_put(obj);
+
+	if (evdi_enable_cursor_blending)
+		evdi_mark_full_screen_dirty(evdi);
+	else
+		evdi_painter_send_cursor_set(evdi->painter, evdi->cursor);
+	return 0;
+}
+
+static int evdi_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
+{
+	struct drm_device *dev = crtc->dev;
+	struct evdi_device *evdi = dev->dev_private;
+
+	EVDI_CHECKPT();
+	evdi_cursor_move(evdi->cursor, x, y);
+
+	if (evdi_enable_cursor_blending)
+		evdi_mark_full_screen_dirty(evdi);
+	else
+		evdi_painter_send_cursor_move(evdi->painter, evdi->cursor);
+
+	return 0;
+}
+
+static struct drm_crtc_helper_funcs evdi_helper_funcs = {
+	.atomic_flush   = evdi_crtc_atomic_flush,
+
+	.dpms           = evdi_crtc_dpms,
+	.commit         = evdi_crtc_commit,
+};
+
+
+static const struct drm_crtc_funcs evdi_crtc_funcs = {
+	.reset                  = drm_atomic_helper_crtc_reset,
+	.destroy                = evdi_crtc_destroy,
+	.set_config             = drm_atomic_helper_set_config,
+	.page_flip              = drm_atomic_helper_page_flip,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,
+
+	.cursor_set2            = evdi_crtc_cursor_set,
+	.cursor_move            = evdi_crtc_cursor_move,
+};
+
+static void evdi_plane_atomic_update(struct drm_plane *plane,
+				     struct drm_plane_state *old_state)
+{
+	if (plane && plane->state && plane->state->fb &&
+	    plane->dev && plane->dev->dev_private) {
+		struct drm_plane_state *state = plane->state;
+		struct drm_framebuffer *fb = state->fb;
+		struct evdi_framebuffer *efb = to_evdi_fb(fb);
+		struct evdi_device *evdi = plane->dev->dev_private;
+
+		const struct drm_clip_rect rect = {
+			0, 0, fb->width, fb->height
+		};
+
+		evdi_painter_mark_dirty(evdi, &rect);
+
+		if (state->fb != old_state->fb ||
+		    evdi_painter_needs_full_modeset(evdi)) {
+			evdi_painter_set_new_scanout_buffer(evdi, efb);
+			evdi_painter_commit_scanout_buffer(evdi);
+		}
+	}
+}
+
+static void evdi_cursor_atomic_get_rect(struct drm_clip_rect *rect,
+				 struct drm_plane_state *state)
+{
+	rect->x1 = (state->crtc_x < 0) ? 0 : state->crtc_x;
+	rect->y1 = (state->crtc_y < 0) ? 0 : state->crtc_y;
+	rect->x2 = state->crtc_x + state->crtc_w;
+	rect->y2 = state->crtc_y + state->crtc_h;
+}
+
+static void evdi_cursor_atomic_update(struct drm_plane *plane,
+				      struct drm_plane_state *old_state)
+{
+	if (plane && plane->state && plane->dev && plane->dev->dev_private) {
+		struct drm_plane_state *state = plane->state;
+		struct evdi_device *evdi = plane->dev->dev_private;
+		struct drm_framebuffer *fb = state->fb;
+		struct evdi_framebuffer *efb = to_evdi_fb(fb);
+
+		struct drm_clip_rect old_rect;
+		struct drm_clip_rect rect;
+		bool cursor_changed = false;
+		bool cursor_position_changed = false;
+		int32_t cursor_position_x = 0;
+		int32_t cursor_position_y = 0;
+
+		mutex_lock(&plane->dev->struct_mutex);
+
+		evdi_cursor_position(evdi->cursor, &cursor_position_x,
+						   &cursor_position_y);
+		evdi_cursor_move(evdi->cursor, state->crtc_x, state->crtc_y);
+		cursor_position_changed = cursor_position_x != state->crtc_x ||
+					  cursor_position_y != state->crtc_y;
+
+		if (fb != old_state->fb) {
+			if (fb != NULL) {
+				uint32_t stride = 4 * fb->width;
+
+				evdi_cursor_set(evdi->cursor,
+						efb->obj,
+						fb->width,
+						fb->height,
+						0,
+						0,
+						fb->format->format,
+						stride);
+			}
+
+			evdi_cursor_enable(evdi->cursor, fb != NULL);
+			cursor_changed = true;
+		}
+
+		mutex_unlock(&plane->dev->struct_mutex);
+
+		if (evdi_enable_cursor_blending) {
+			evdi_cursor_atomic_get_rect(&old_rect, old_state);
+			evdi_cursor_atomic_get_rect(&rect, state);
+
+			evdi_painter_mark_dirty(evdi, &old_rect);
+			evdi_painter_mark_dirty(evdi, &rect);
+			return;
+		}
+		if (cursor_changed)
+			evdi_painter_send_cursor_set(evdi->painter,
+						     evdi->cursor);
+		if (cursor_position_changed)
+			evdi_painter_send_cursor_move(evdi->painter,
+						      evdi->cursor);
+	}
+}
+
+static const struct drm_plane_helper_funcs evdi_plane_helper_funcs = {
+	.atomic_update = evdi_plane_atomic_update
+};
+
+static const struct drm_plane_helper_funcs evdi_cursor_helper_funcs = {
+	.atomic_update = evdi_cursor_atomic_update
+};
+
+static const struct drm_plane_funcs evdi_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = drm_plane_cleanup,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static const uint32_t formats[] = {
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+};
+
+static struct drm_plane *evdi_create_plane(
+		struct drm_device *dev,
+		enum drm_plane_type type,
+		const struct drm_plane_helper_funcs *helper_funcs)
+{
+	struct drm_plane *plane;
+	int ret;
+
+	plane = kzalloc(sizeof(*plane), GFP_KERNEL);
+	if (plane == NULL) {
+		EVDI_ERROR("Failed to allocate primary plane\n");
+		return NULL;
+	}
+	plane->format_default = true;
+
+	ret = drm_universal_plane_init(dev,
+				       plane,
+				       0xFF,
+				       &evdi_plane_funcs,
+				       formats,
+				       ARRAY_SIZE(formats),
+				       NULL,
+				       type, NULL);
+	if (ret) {
+		EVDI_ERROR("Failed to initialize primary plane\n");
+		kfree(plane);
+		return NULL;
+	}
+
+	drm_plane_helper_add(plane, helper_funcs);
+
+	return plane;
+}
+
+static int evdi_crtc_init(struct drm_device *dev)
+{
+	struct drm_crtc *crtc = NULL;
+	struct drm_plane *primary = NULL;
+	int status = 0;
+
+	EVDI_CHECKPT();
+	crtc = kzalloc(sizeof(struct drm_crtc), GFP_KERNEL);
+	if (crtc == NULL)
+		return -ENOMEM;
+
+	primary = evdi_create_plane(dev, DRM_PLANE_TYPE_PRIMARY,
+					&evdi_plane_helper_funcs);
+	status = drm_crtc_init_with_planes(dev, crtc, primary, NULL,
+						&evdi_crtc_funcs, NULL);
+
+	EVDI_INFO("drm_crtc_init: %d p%p\n", status, primary);
+	drm_crtc_helper_add(crtc, &evdi_helper_funcs);
+
+	return 0;
+}
+
+static int evdi_atomic_check(struct drm_device *dev,
+				struct drm_atomic_state *state)
+{
+	struct drm_crtc *crtc;
+	struct drm_crtc_state *crtc_state = NULL;
+	int i;
+	struct evdi_device *evdi = dev->dev_private;
+
+
+	if (evdi_painter_needs_full_modeset(evdi)) {
+		for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
+			crtc_state->active_changed = true;
+			crtc_state->mode_changed = true;
+		}
+	}
+
+	return drm_atomic_helper_check(dev, state);
+}
+
+
+static const struct drm_mode_config_funcs evdi_mode_funcs = {
+	.fb_create = evdi_fb_user_fb_create,
+	.output_poll_changed = NULL,
+	.atomic_commit = drm_atomic_helper_commit,
+	.atomic_check = evdi_atomic_check
+};
+
+void evdi_modeset_init(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+
+	EVDI_CHECKPT();
+	drm_mode_config_init(dev);
+
+	dev->mode_config.min_width = 64;
+	dev->mode_config.min_height = 64;
+
+	dev->mode_config.max_width = 3840;
+	dev->mode_config.max_height = 2160;
+
+	dev->mode_config.prefer_shadow = 0;
+	dev->mode_config.preferred_depth = 24;
+
+	dev->mode_config.funcs = &evdi_mode_funcs;
+
+	drm_dev_set_unique(dev, dev_name(dev->dev));
+	evdi_crtc_init(dev);
+
+	encoder = evdi_encoder_init(dev);
+
+	evdi_connector_init(dev, encoder);
+
+	drm_mode_config_reset(dev);
+}
+
+void evdi_modeset_cleanup(struct drm_device *dev)
+{
+	EVDI_CHECKPT();
+	drm_mode_config_cleanup(dev);
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_painter.c b/drivers/gpu/drm/evdi/evdi_painter.c
--- a/drivers/gpu/drm/evdi/evdi_painter.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_painter.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,1089 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2013 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_edid.h>
+#include <uapi/drm/evdi_drm.h>
+#include "evdi_drv.h"
+#include "evdi_cursor.h"
+#include "evdi_i2c.h"
+#include <linux/mutex.h>
+#include <linux/compiler.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+
+struct evdi_event_cursor_set_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_cursor_set cursor_set;
+};
+
+struct evdi_event_cursor_move_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_cursor_move cursor_move;
+};
+
+struct evdi_event_update_ready_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_update_ready update_ready;
+};
+
+struct evdi_event_dpms_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_dpms dpms;
+};
+
+struct evdi_event_mode_changed_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_mode_changed mode_changed;
+};
+
+struct evdi_event_crtc_state_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_crtc_state crtc_state;
+};
+
+struct evdi_event_ddcci_data_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_ddcci_data ddcci_data;
+};
+
+#define MAX_DIRTS 16
+#define EDID_EXT_BLOCK_SIZE 128
+#define MAX_EDID_SIZE (255 * EDID_EXT_BLOCK_SIZE + sizeof(struct edid))
+#define I2C_ADDRESS_DDCCI 0x37
+#define DDCCI_TIMEOUT_MS 50
+
+struct evdi_painter {
+	bool is_connected;
+	struct edid *edid;
+	unsigned int edid_length;
+
+	struct mutex lock;
+	struct mutex new_scanout_fb_lock;
+	struct drm_clip_rect dirty_rects[MAX_DIRTS];
+	int num_dirts;
+	struct evdi_framebuffer *new_scanout_fb;
+	struct evdi_framebuffer *scanout_fb;
+
+	struct drm_file *drm_filp;
+
+	bool was_update_requested;
+	bool needs_full_modeset;
+
+	struct completion ddcci_response_received;
+	char *ddcci_buffer;
+	unsigned int ddcci_buffer_length;
+};
+
+static void expand_rect(struct drm_clip_rect *a, const struct drm_clip_rect *b)
+{
+	a->x1 = min(a->x1, b->x1);
+	a->y1 = min(a->y1, b->y1);
+	a->x2 = max(a->x2, b->x2);
+	a->y2 = max(a->y2, b->y2);
+}
+
+static int rect_area(const struct drm_clip_rect *r)
+{
+	return (r->x2 - r->x1) * (r->y2 - r->y1);
+}
+
+static void merge_dirty_rects(struct drm_clip_rect *rects, int *count)
+{
+	int a, b;
+
+	for (a = 0; a < *count - 1; ++a) {
+		for (b = a + 1; b < *count;) {
+			/* collapse to bounding rect if it is fewer pixels */
+			const int area_a = rect_area(&rects[a]);
+			const int area_b = rect_area(&rects[b]);
+			struct drm_clip_rect bounding_rect = rects[a];
+
+			expand_rect(&bounding_rect, &rects[b]);
+
+			if (rect_area(&bounding_rect) <= area_a + area_b) {
+				rects[a] = bounding_rect;
+				rects[b] = rects[*count - 1];
+				/* repass */
+				b = a + 1;
+				--*count;
+			} else {
+				++b;
+			}
+		}
+	}
+}
+
+static void collapse_dirty_rects(struct drm_clip_rect *rects, int *count)
+{
+	int i;
+
+	EVDI_CHECKPT();
+	EVDI_WARN("Not enough space for clip rects! Rects will be collapsed");
+
+	for (i = 1; i < *count; ++i)
+		expand_rect(&rects[0], &rects[i]);
+
+	*count = 1;
+}
+
+static int copy_primary_pixels(struct evdi_framebuffer *ufb,
+			       char __user *buffer,
+			       int buf_byte_stride,
+			       int num_rects, struct drm_clip_rect *rects,
+			       int const max_x,
+			       int const max_y)
+{
+	struct drm_framebuffer *fb = &ufb->base;
+	struct drm_clip_rect *r;
+
+	EVDI_CHECKPT();
+
+	for (r = rects; r != rects + num_rects; ++r) {
+		const int byte_offset = r->x1 * 4;
+		const int byte_span = (r->x2 - r->x1) * 4;
+		const int src_offset = fb->pitches[0] * r->y1 + byte_offset;
+		const char *src = (char *)ufb->obj->vmapping + src_offset;
+		const int dst_offset = buf_byte_stride * r->y1 + byte_offset;
+		char __user *dst = buffer + dst_offset;
+		int y = r->y2 - r->y1;
+
+		/* rect size may correspond to previous resolution */
+		if (max_x < r->x2 || max_y < r->y2) {
+			EVDI_WARN("Rect size beyond expected dimensions\n");
+			return -EFAULT;
+		}
+
+		EVDI_VERBOSE("copy rect %d,%d-%d,%d\n", r->x1, r->y1, r->x2,
+			     r->y2);
+
+		for (; y > 0; --y) {
+			if (copy_to_user(dst, src, byte_span))
+				return -EFAULT;
+
+			src += fb->pitches[0];
+			dst += buf_byte_stride;
+		}
+	}
+
+	return 0;
+}
+
+static void copy_cursor_pixels(struct evdi_framebuffer *efb,
+			      char __user *buffer,
+			      int buf_byte_stride,
+			      struct evdi_cursor *cursor)
+{
+	if (evdi_enable_cursor_blending) {
+		evdi_cursor_lock(cursor);
+		if (evdi_cursor_compose_and_copy(cursor,
+						   efb,
+						   buffer,
+						   buf_byte_stride))
+			EVDI_ERROR("Failed to blend cursor\n");
+
+		evdi_cursor_unlock(cursor);
+	}
+}
+
+#define painter_lock(painter)                           \
+	do {                                            \
+		EVDI_VERBOSE("Painter lock\n");         \
+		mutex_lock(&painter->lock);             \
+	} while (0)
+
+#define painter_unlock(painter)                         \
+	do {                                            \
+		EVDI_VERBOSE("Painter unlock\n");       \
+		mutex_unlock(&painter->lock);           \
+	} while (0)
+
+bool evdi_painter_is_connected(struct evdi_device *evdi)
+{
+	if (evdi && evdi->painter)
+		return evdi->painter->is_connected;
+	return false;
+}
+
+u8 *evdi_painter_get_edid_copy(struct evdi_device *evdi)
+{
+	u8 *block = NULL;
+
+	EVDI_CHECKPT();
+
+	painter_lock(evdi->painter);
+	if (evdi_painter_is_connected(evdi) &&
+		evdi->painter->edid &&
+		evdi->painter->edid_length) {
+		block = kmalloc(evdi->painter->edid_length, GFP_KERNEL);
+		if (block) {
+			memcpy(block,
+			       evdi->painter->edid,
+			       evdi->painter->edid_length);
+			EVDI_DEBUG("(dev=%d) %02x %02x %02x\n", evdi->dev_index,
+				   block[0], block[1], block[2]);
+		}
+	}
+	painter_unlock(evdi->painter);
+	return block;
+}
+
+static void evdi_painter_send_event(struct drm_file *drm_filp,
+				    struct list_head *event_link)
+{
+	list_add_tail(event_link, &drm_filp->event_list);
+	wake_up_interruptible(&drm_filp->event_wait);
+}
+
+static void evdi_painter_send_update_ready(struct evdi_painter *painter)
+{
+	struct evdi_event_update_ready_pending *event;
+
+	if (painter->drm_filp) {
+		event = kzalloc(sizeof(*event), GFP_KERNEL);
+		event->update_ready.base.type = DRM_EVDI_EVENT_UPDATE_READY;
+		event->update_ready.base.length = sizeof(event->update_ready);
+		event->base.event = &event->update_ready.base;
+		event->base.file_priv = painter->drm_filp;
+		evdi_painter_send_event(painter->drm_filp, &event->base.link);
+	} else {
+		EVDI_WARN("Painter is not connected!");
+	}
+}
+
+static uint32_t evdi_painter_get_gem_handle(struct evdi_painter *painter,
+					   struct evdi_gem_object *obj)
+{
+	uint32_t handle = 0;
+
+	if (!obj)
+		return 0;
+
+	handle = evdi_gem_object_handle_lookup(painter->drm_filp, &obj->base);
+
+	if (handle)
+		return handle;
+
+	if (drm_gem_handle_create(painter->drm_filp,
+			      &obj->base, &handle)) {
+		EVDI_ERROR("Failed to create gem handle for %p\n",
+			painter->drm_filp);
+	}
+
+	return handle;
+}
+
+void evdi_painter_send_cursor_set(struct evdi_painter *painter,
+				  struct evdi_cursor *cursor)
+{
+	struct evdi_event_cursor_set_pending *event;
+	struct evdi_gem_object *eobj = NULL;
+
+	if (painter->drm_filp) {
+		event = kzalloc(sizeof(*event), GFP_KERNEL);
+		event->cursor_set.base.type = DRM_EVDI_EVENT_CURSOR_SET;
+		event->cursor_set.base.length =
+			sizeof(event->cursor_set);
+
+		evdi_cursor_lock(cursor);
+		event->cursor_set.enabled = evdi_cursor_enabled(cursor);
+		evdi_cursor_hotpoint(cursor,
+			&event->cursor_set.hot_x,
+			&event->cursor_set.hot_y);
+		evdi_cursor_size(cursor,
+			&event->cursor_set.width,
+			&event->cursor_set.height);
+		evdi_cursor_format(cursor,
+			&event->cursor_set.pixel_format);
+		evdi_cursor_stride(cursor,
+			&event->cursor_set.stride);
+		eobj = evdi_cursor_gem(cursor);
+		event->cursor_set.buffer_handle =
+			evdi_painter_get_gem_handle(painter, eobj);
+		if (eobj)
+			event->cursor_set.buffer_length = eobj->base.size;
+		if (!event->cursor_set.buffer_handle) {
+			event->cursor_set.enabled = false;
+			event->cursor_set.buffer_length = 0;
+		}
+		evdi_cursor_unlock(cursor);
+
+		event->base.event = &event->cursor_set.base;
+		event->base.file_priv = painter->drm_filp;
+		evdi_painter_send_event(painter->drm_filp, &event->base.link);
+	} else {
+		EVDI_WARN("Painter is not connected!");
+	}
+}
+
+void evdi_painter_send_cursor_move(struct evdi_painter *painter,
+				   struct evdi_cursor *cursor)
+{
+	struct evdi_event_cursor_move_pending *event;
+
+	if (painter->drm_filp) {
+		event = kzalloc(sizeof(*event), GFP_KERNEL);
+		event->cursor_move.base.type = DRM_EVDI_EVENT_CURSOR_MOVE;
+		event->cursor_move.base.length = sizeof(event->cursor_move);
+
+		evdi_cursor_lock(cursor);
+		evdi_cursor_position(
+			cursor,
+			&event->cursor_move.x,
+			&event->cursor_move.y);
+		evdi_cursor_unlock(cursor);
+
+		event->base.event = &event->cursor_move.base;
+		event->base.file_priv = painter->drm_filp;
+		evdi_painter_send_event(painter->drm_filp, &event->base.link);
+	} else {
+		EVDI_WARN("Painter is not connected!");
+	}
+}
+
+static void evdi_painter_send_dpms(struct evdi_painter *painter, int mode)
+{
+	struct evdi_event_dpms_pending *event;
+
+	if (painter->drm_filp) {
+		event = kzalloc(sizeof(*event), GFP_KERNEL);
+		event->dpms.base.type = DRM_EVDI_EVENT_DPMS;
+		event->dpms.base.length = sizeof(event->dpms);
+		event->dpms.mode = mode;
+		event->base.event = &event->dpms.base;
+		event->base.file_priv = painter->drm_filp;
+		evdi_painter_send_event(painter->drm_filp, &event->base.link);
+	} else {
+		EVDI_WARN("Painter is not connected!");
+	}
+}
+
+static void evdi_painter_send_crtc_state(struct evdi_painter *painter,
+					 int state)
+{
+	struct evdi_event_crtc_state_pending *event;
+
+	if (painter->drm_filp) {
+		event = kzalloc(sizeof(*event), GFP_KERNEL);
+		event->crtc_state.base.type = DRM_EVDI_EVENT_CRTC_STATE;
+		event->crtc_state.base.length = sizeof(event->crtc_state);
+		event->crtc_state.state = state;
+		event->base.event = &event->crtc_state.base;
+		event->base.file_priv = painter->drm_filp;
+		evdi_painter_send_event(painter->drm_filp, &event->base.link);
+	} else {
+		EVDI_WARN("Painter is not connected!");
+	}
+}
+
+static void evdi_painter_send_mode_changed(
+	struct evdi_painter *painter,
+	struct drm_display_mode *current_mode,
+	int32_t bits_per_pixel,
+	uint32_t pixel_format)
+{
+	struct evdi_event_mode_changed_pending *event;
+
+	if (painter->drm_filp) {
+		event = kzalloc(sizeof(*event), GFP_KERNEL);
+		event->mode_changed.base.type = DRM_EVDI_EVENT_MODE_CHANGED;
+		event->mode_changed.base.length = sizeof(event->mode_changed);
+
+		event->mode_changed.hdisplay = current_mode->hdisplay;
+		event->mode_changed.vdisplay = current_mode->vdisplay;
+		event->mode_changed.vrefresh =
+			drm_mode_vrefresh(current_mode);
+		event->mode_changed.bits_per_pixel = bits_per_pixel;
+		event->mode_changed.pixel_format = pixel_format;
+
+		event->base.event = &event->mode_changed.base;
+		event->base.file_priv = painter->drm_filp;
+		evdi_painter_send_event(painter->drm_filp, &event->base.link);
+	} else {
+		EVDI_WARN("Painter is not connected!");
+	}
+}
+
+struct drm_clip_rect evdi_painter_framebuffer_size(
+	struct evdi_painter *painter)
+{
+	struct drm_clip_rect rect = {0, 0, 0, 0};
+	struct evdi_framebuffer *efb = NULL;
+
+	if (painter == NULL) {
+		EVDI_WARN("Painter is not connected!");
+		return rect;
+	}
+
+	painter_lock(painter);
+	efb = painter->scanout_fb;
+	if (!efb) {
+		EVDI_DEBUG("Scanout buffer not set.");
+		goto unlock;
+	}
+	rect.x1 = 0;
+	rect.y1 = 0;
+	rect.x2 = efb->base.width;
+	rect.y2 = efb->base.height;
+unlock:
+	painter_unlock(painter);
+	return rect;
+}
+
+void evdi_painter_mark_dirty(struct evdi_device *evdi,
+			     const struct drm_clip_rect *dirty_rect)
+{
+	struct drm_clip_rect rect;
+	struct evdi_framebuffer *efb = NULL;
+	struct evdi_painter *painter = evdi->painter;
+
+	painter_lock(evdi->painter);
+	efb = evdi->painter->scanout_fb;
+	if (!efb) {
+		EVDI_WARN("(dev=%d) Skip clip rect. Scanout buffer not set.\n",
+			  evdi->dev_index);
+		goto unlock;
+	}
+
+	rect = evdi_framebuffer_sanitize_rect(efb, dirty_rect);
+
+	EVDI_VERBOSE("(dev=%d) %d,%d-%d,%d\n", evdi->dev_index, rect.x1,
+		     rect.y1, rect.x2, rect.y2);
+
+	if (painter->num_dirts == MAX_DIRTS)
+		merge_dirty_rects(&painter->dirty_rects[0],
+				  &painter->num_dirts);
+
+	if (painter->num_dirts == MAX_DIRTS)
+		collapse_dirty_rects(&painter->dirty_rects[0],
+				     &painter->num_dirts);
+
+	memcpy(&painter->dirty_rects[painter->num_dirts], &rect, sizeof(rect));
+	painter->num_dirts++;
+
+unlock:
+	painter_unlock(evdi->painter);
+}
+
+void evdi_painter_send_update_ready_if_needed(struct evdi_device *evdi)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	painter_lock(evdi->painter);
+	if (painter->was_update_requested) {
+		evdi_painter_send_update_ready(painter);
+		painter->was_update_requested = false;
+	}
+	painter_unlock(evdi->painter);
+}
+
+void evdi_painter_dpms_notify(struct evdi_device *evdi, int mode)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	if (painter) {
+		EVDI_DEBUG("(dev=%d) Notifying dpms mode: %d\n",
+			   evdi->dev_index, mode);
+		evdi_painter_send_dpms(painter, mode);
+	} else {
+		EVDI_WARN("Painter does not exist!");
+	}
+}
+
+void evdi_painter_crtc_state_notify(struct evdi_device *evdi, int state)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	if (painter) {
+		EVDI_DEBUG("(dev=%d) Notifying crtc state: %d\n",
+			   evdi->dev_index, state);
+		evdi_painter_send_crtc_state(painter, state);
+	} else {
+		EVDI_WARN("Painter does not exist!");
+	}
+}
+
+void evdi_painter_mode_changed_notify(struct evdi_device *evdi,
+				      struct drm_display_mode *new_mode)
+{
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_framebuffer *fb = &painter->scanout_fb->base;
+	int bits_per_pixel;
+	uint32_t pixel_format;
+
+	if (fb == NULL)
+		return;
+
+	bits_per_pixel = fb->format->cpp[0];
+	pixel_format = fb->format->format;
+
+	EVDI_DEBUG("(dev=%d) Notifying mode changed: %dx%d@%d; bpp %d; ",
+		   evdi->dev_index, new_mode->hdisplay, new_mode->vdisplay,
+		   drm_mode_vrefresh(new_mode), bits_per_pixel);
+	EVDI_DEBUG("pixel format %d\n", pixel_format);
+
+	evdi_painter_send_mode_changed(painter,
+				       new_mode,
+				       bits_per_pixel,
+				       pixel_format);
+	if (painter)
+		painter->needs_full_modeset = false;
+}
+
+static void evdi_add_i2c_adapter(struct evdi_device *evdi)
+{
+	struct drm_device *ddev = evdi->ddev;
+	struct platform_device *platdev = to_platform_device(ddev->dev);
+	int result = 0;
+
+	evdi->i2c_adapter = kzalloc(sizeof(*evdi->i2c_adapter), GFP_KERNEL);
+
+	if (!evdi->i2c_adapter) {
+		EVDI_ERROR("(dev=%d) Failed to allocate for i2c adapter",
+			evdi->dev_index);
+		return;
+	}
+
+	result = evdi_i2c_add(evdi->i2c_adapter, &platdev->dev,
+		ddev->dev_private);
+
+	if (result) {
+		kfree(evdi->i2c_adapter);
+		evdi->i2c_adapter = NULL;
+		EVDI_ERROR("(dev=%d) Failed to add i2c adapter, error %d",
+			evdi->dev_index, result);
+		return;
+	}
+
+	EVDI_DEBUG("(dev=%d) Added i2c adapter bus number %d",
+		evdi->dev_index, evdi->i2c_adapter->nr);
+
+	result = sysfs_create_link(&evdi->conn->kdev->kobj,
+			&evdi->i2c_adapter->dev.kobj, "ddc");
+
+	if (result) {
+		EVDI_ERROR("(dev=%d) Failed to create sysfs link, error %d",
+			evdi->dev_index, result);
+		return;
+	}
+}
+
+static void evdi_remove_i2c_adapter(struct evdi_device *evdi)
+{
+	if (evdi->i2c_adapter) {
+		EVDI_DEBUG("(dev=%d) Removing i2c adapter bus number %d",
+			evdi->dev_index, evdi->i2c_adapter->nr);
+
+		sysfs_remove_link(&evdi->conn->kdev->kobj, "ddc");
+
+		evdi_i2c_remove(evdi->i2c_adapter);
+
+		kfree(evdi->i2c_adapter);
+		evdi->i2c_adapter = NULL;
+	}
+}
+
+static int
+evdi_painter_connect(struct evdi_device *evdi,
+		     void const __user *edid_data, unsigned int edid_length,
+		     uint32_t sku_area_limit,
+		     struct drm_file *file, int dev_index)
+{
+	struct evdi_painter *painter = evdi->painter;
+	struct edid *new_edid = NULL;
+	int expected_edid_size = 0;
+
+	EVDI_CHECKPT();
+
+	if (edid_length < sizeof(struct edid)) {
+		EVDI_ERROR("Edid length too small\n");
+		return -EINVAL;
+	}
+
+	if (edid_length > MAX_EDID_SIZE) {
+		EVDI_ERROR("Edid length too large\n");
+		return -EINVAL;
+	}
+
+	new_edid = kzalloc(edid_length, GFP_KERNEL);
+	if (!new_edid)
+		return -ENOMEM;
+
+	if (copy_from_user(new_edid, edid_data, edid_length)) {
+		EVDI_ERROR("(dev=%d) Failed to read edid\n", dev_index);
+		kfree(new_edid);
+		return -EFAULT;
+	}
+
+	expected_edid_size = sizeof(struct edid) +
+			     new_edid->extensions * EDID_EXT_BLOCK_SIZE;
+	if (expected_edid_size != edid_length) {
+		EVDI_ERROR("Wrong edid size. Expected %d but is %d\n",
+			   expected_edid_size, edid_length);
+		kfree(new_edid);
+		return -EINVAL;
+	}
+
+	if (painter->drm_filp)
+		EVDI_WARN("(dev=%d) Double connect - replacing %p with %p\n",
+			  dev_index, painter->drm_filp, file);
+
+	painter_lock(painter);
+
+	evdi->dev_index = dev_index;
+	evdi->sku_area_limit = sku_area_limit;
+	painter->drm_filp = file;
+	kfree(painter->edid);
+	painter->edid_length = edid_length;
+	painter->edid = new_edid;
+	painter->is_connected = true;
+	painter->needs_full_modeset = true;
+
+	evdi_add_i2c_adapter(evdi);
+
+	painter_unlock(painter);
+
+	EVDI_DEBUG("(dev=%d) Connected with %p\n", evdi->dev_index,
+		   painter->drm_filp);
+
+	drm_helper_hpd_irq_event(evdi->ddev);
+
+
+	return 0;
+}
+
+static int evdi_painter_disconnect(struct evdi_device *evdi,
+	struct drm_file *file)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	EVDI_CHECKPT();
+
+	painter_lock(painter);
+
+	if (file != painter->drm_filp) {
+		EVDI_WARN
+		    ("(dev=%d) An unknown connection to %p tries to close us",
+		     evdi->dev_index, file);
+		EVDI_WARN(" - ignoring\n");
+
+		painter_unlock(painter);
+		return -EFAULT;
+	}
+
+	evdi_painter_set_new_scanout_buffer(evdi, NULL);
+
+	if (painter->scanout_fb) {
+		drm_framebuffer_put(&painter->scanout_fb->base);
+		painter->scanout_fb = NULL;
+	}
+
+	painter->is_connected = false;
+
+	EVDI_DEBUG("(dev=%d) Disconnected from %p\n", evdi->dev_index,
+		   painter->drm_filp);
+
+	evdi_cursor_enable(evdi->cursor, false);
+
+	kfree(painter->ddcci_buffer);
+	painter->ddcci_buffer = NULL;
+	painter->ddcci_buffer_length = 0;
+
+	evdi_remove_i2c_adapter(evdi);
+
+	painter->drm_filp = NULL;
+
+	painter->was_update_requested = false;
+
+	painter_unlock(painter);
+
+	// Signal anything waiting for ddc/ci response with NULL buffer
+	complete(&painter->ddcci_response_received);
+
+	drm_helper_hpd_irq_event(evdi->ddev);
+	return 0;
+}
+
+void evdi_painter_close(struct evdi_device *evdi, struct drm_file *file)
+{
+	EVDI_CHECKPT();
+
+	if (evdi->painter)
+		evdi_painter_disconnect(evdi, file);
+	else
+		EVDI_WARN("Painter does not exist!");
+}
+
+int evdi_painter_connect_ioctl(struct drm_device *drm_dev, void *data,
+			       struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_evdi_connect *cmd = data;
+	int ret;
+
+	EVDI_CHECKPT();
+	if (painter) {
+		if (cmd->connected)
+			ret = evdi_painter_connect(evdi,
+					     cmd->edid,
+					     cmd->edid_length,
+					     cmd->sku_area_limit,
+					     file,
+					     cmd->dev_index);
+		else
+			ret = evdi_painter_disconnect(evdi, file);
+
+		return ret;
+	}
+	EVDI_WARN("Painter does not exist!");
+	return -ENODEV;
+}
+
+int evdi_painter_grabpix_ioctl(struct drm_device *drm_dev, void *data,
+			       __always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_evdi_grabpix *cmd = data;
+	struct drm_framebuffer *fb = NULL;
+	struct evdi_framebuffer *efb = NULL;
+	int err = 0;
+
+	EVDI_CHECKPT();
+
+	if (!painter)
+		return -ENODEV;
+
+	painter_lock(painter);
+
+	efb = painter->scanout_fb;
+
+	if (!efb) {
+		EVDI_ERROR("Scanout buffer not set\n");
+		err = -EAGAIN;
+		goto unlock;
+	}
+
+	if (painter->was_update_requested) {
+		EVDI_WARN("(dev=%d) Update ready not sent,",
+			  evdi->dev_index);
+		EVDI_WARN(" but pixels are grabbed.\n");
+	}
+
+	fb = &efb->base;
+	if (!efb->obj->vmapping) {
+		if (evdi_gem_vmap(efb->obj) == -ENOMEM) {
+			EVDI_ERROR("Failed to map scanout buffer\n");
+			err = -EFAULT;
+			goto unlock;
+		}
+		if (!efb->obj->vmapping) {
+			EVDI_ERROR("Inexistent vmapping\n");
+			err = -EFAULT;
+			goto unlock;
+		}
+	}
+
+	if (cmd->buf_width != fb->width ||
+		cmd->buf_height != fb->height) {
+		EVDI_ERROR("Invalid buffer dimension\n");
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	if (cmd->num_rects < 1) {
+		EVDI_ERROR("No space for clip rects\n");
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	if (cmd->mode == EVDI_GRABPIX_MODE_DIRTY) {
+		if (painter->num_dirts < 0) {
+			err = -EAGAIN;
+			goto unlock;
+		}
+		merge_dirty_rects(&painter->dirty_rects[0],
+				  &painter->num_dirts);
+		if (painter->num_dirts > cmd->num_rects)
+			collapse_dirty_rects(&painter->dirty_rects[0],
+						 &painter->num_dirts);
+
+		cmd->num_rects = painter->num_dirts;
+
+		if (copy_to_user(cmd->rects, painter->dirty_rects,
+			cmd->num_rects * sizeof(cmd->rects[0])))
+			err = -EFAULT;
+		if (err == 0)
+			err = copy_primary_pixels(efb,
+						  cmd->buffer,
+						  cmd->buf_byte_stride,
+						  painter->num_dirts,
+						  painter->dirty_rects,
+						  cmd->buf_width,
+						  cmd->buf_height);
+		if (err == 0)
+			copy_cursor_pixels(efb,
+					   cmd->buffer,
+					   cmd->buf_byte_stride,
+					   evdi->cursor);
+
+		painter->num_dirts = 0;
+	}
+unlock:
+	painter_unlock(painter);
+
+	return err;
+}
+
+int evdi_painter_request_update_ioctl(struct drm_device *drm_dev,
+				      __always_unused void *data,
+				      __always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	int result = 0;
+
+	if (painter) {
+		painter_lock(painter);
+
+		if (painter->was_update_requested) {
+			EVDI_WARN
+			  ("(dev=%d) Update was already requested - ignoring\n",
+			   evdi->dev_index);
+		} else {
+			if (painter->num_dirts > 0)
+				result = 1;
+			else
+				painter->was_update_requested = true;
+		}
+
+		painter_unlock(painter);
+
+		return result;
+	} else {
+		return -ENODEV;
+	}
+}
+
+int evdi_painter_init(struct evdi_device *dev)
+{
+	EVDI_CHECKPT();
+	dev->painter = kzalloc(sizeof(*dev->painter), GFP_KERNEL);
+	if (dev->painter) {
+		mutex_init(&dev->painter->lock);
+		mutex_init(&dev->painter->new_scanout_fb_lock);
+		dev->painter->edid = NULL;
+		dev->painter->edid_length = 0;
+		dev->painter->needs_full_modeset = true;
+		init_completion(&dev->painter->ddcci_response_received);
+		return 0;
+	}
+	return -ENOMEM;
+}
+
+void evdi_painter_cleanup(struct evdi_device *evdi)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	EVDI_CHECKPT();
+	if (painter) {
+		painter_lock(painter);
+		kfree(painter->edid);
+		painter->edid_length = 0;
+		painter->edid = 0;
+		painter_unlock(painter);
+	} else {
+		EVDI_WARN("Painter does not exist\n");
+	}
+}
+
+/*
+ * This can be called from multiple threads so we need to lock during
+ * *new_scanout_fb* assignment.
+ * It is called from *evdi_crtc_page_flip* which must return immediately.
+ * If we lock here whole painter object it will interfere with grab_pics
+ * ioctl (which can take some time).
+ * Because of that we lock only on the *new_scanout_fb*.
+ */
+void evdi_painter_set_new_scanout_buffer(struct evdi_device *evdi,
+					 struct evdi_framebuffer *newfb)
+{
+	struct evdi_painter *painter = evdi->painter;
+	struct evdi_framebuffer *oldfb = NULL;
+
+	if (newfb)
+		drm_framebuffer_get(&newfb->base);
+
+	mutex_lock(&painter->new_scanout_fb_lock);
+	oldfb = painter->new_scanout_fb;
+	painter->new_scanout_fb = newfb;
+	mutex_unlock(&painter->new_scanout_fb_lock);
+
+	if (oldfb)
+		drm_framebuffer_put(&oldfb->base);
+}
+
+void evdi_painter_commit_scanout_buffer(struct evdi_device *evdi)
+{
+	struct evdi_painter *painter = evdi->painter;
+	struct evdi_framebuffer *newfb = NULL;
+	struct evdi_framebuffer *oldfb = NULL;
+
+	painter_lock(painter);
+	mutex_lock(&painter->new_scanout_fb_lock);
+
+	newfb = painter->new_scanout_fb;
+
+	if (newfb)
+		drm_framebuffer_get(&newfb->base);
+
+	oldfb = painter->scanout_fb;
+	painter->scanout_fb = newfb;
+
+	mutex_unlock(&painter->new_scanout_fb_lock);
+	painter_unlock(painter);
+
+	if (oldfb)
+		drm_framebuffer_put(&oldfb->base);
+}
+
+bool evdi_painter_needs_full_modeset(struct evdi_device *evdi)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	if (painter)
+		return painter->needs_full_modeset;
+	return false;
+}
+
+static struct drm_pending_event *create_ddcci_data_event(struct i2c_msg *msg)
+{
+	struct evdi_event_ddcci_data_pending *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event || !msg) {
+		EVDI_ERROR("Failed to create ddcci data event");
+		return NULL;
+	}
+
+	event->ddcci_data.base.type = DRM_EVDI_EVENT_DDCCI_DATA;
+	event->ddcci_data.base.length = sizeof(event->ddcci_data);
+	// Truncate buffers to a maximum of 64 bytes
+	event->ddcci_data.buffer_length = min_t(__u16, msg->len,
+		sizeof(event->ddcci_data.buffer));
+	memcpy(event->ddcci_data.buffer, msg->buf,
+		event->ddcci_data.buffer_length);
+	event->ddcci_data.flags = msg->flags;
+	event->ddcci_data.address = msg->addr;
+
+	event->base.event = &event->ddcci_data.base;
+	return &event->base;
+}
+
+static void evdi_painter_ddcci_data(struct evdi_painter *painter,
+		struct i2c_msg *msg)
+{
+	struct drm_pending_event *event;
+
+	if (!painter->drm_filp) {
+		EVDI_WARN("Painter is not connected!");
+		return;
+	}
+
+	event = create_ddcci_data_event(msg);
+
+	reinit_completion(&painter->ddcci_response_received);
+	evdi_painter_send_event(painter->drm_filp, &event->link);
+
+	if (wait_for_completion_interruptible_timeout(
+		&painter->ddcci_response_received,
+		msecs_to_jiffies(DDCCI_TIMEOUT_MS)) > 0) {
+
+		// Match expected buffer length including any truncation
+		const uint32_t expected_response_length = min_t(__u16, msg->len,
+				DDCCI_BUFFER_SIZE);
+
+		painter_lock(painter);
+
+		if (expected_response_length != painter->ddcci_buffer_length)
+			EVDI_WARN("DDCCI buffer length mismatch");
+		else if (painter->ddcci_buffer)
+			memcpy(msg->buf, painter->ddcci_buffer,
+					painter->ddcci_buffer_length);
+		else
+			EVDI_WARN("Ignoring NULL DDCCI buffer");
+
+		painter_unlock(painter);
+	} else {
+		EVDI_WARN("DDCCI response timeout");
+	}
+}
+
+bool evdi_painter_i2c_data_notify(struct evdi_device *evdi, struct i2c_msg *msg)
+{
+	struct evdi_painter *painter = evdi->painter;
+
+	if (!evdi_painter_is_connected(evdi)) {
+		EVDI_WARN("Painter not connected");
+		return false;
+	}
+
+	if (!msg) {
+		EVDI_WARN("Ignored NULL ddc/ci message");
+		return false;
+	}
+
+	if (msg->addr != I2C_ADDRESS_DDCCI) {
+		EVDI_DEBUG("Ignored ddc/ci data for address 0x%x\n", msg->addr);
+		return false;
+	}
+
+	evdi_painter_ddcci_data(painter, msg);
+	return true;
+}
+
+int evdi_painter_ddcci_response_ioctl(struct drm_device *drm_dev, void *data,
+				__always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_evdi_ddcci_response *cmd = data;
+	int result = 0;
+
+	painter_lock(painter);
+
+	// Truncate any read to 64 bytes
+	painter->ddcci_buffer_length = min_t(uint32_t, cmd->buffer_length,
+			DDCCI_BUFFER_SIZE);
+
+	kfree(painter->ddcci_buffer);
+	painter->ddcci_buffer = kzalloc(painter->ddcci_buffer_length,
+			GFP_KERNEL);
+	if (!painter->ddcci_buffer) {
+		EVDI_ERROR("DDC buffer allocation failed\n");
+		result = -ENOMEM;
+		goto unlock;
+	}
+
+	if (copy_from_user(painter->ddcci_buffer, cmd->buffer,
+		painter->ddcci_buffer_length)) {
+		EVDI_ERROR("Failed to read ddcci_buffer\n");
+		kfree(painter->ddcci_buffer);
+		painter->ddcci_buffer = NULL;
+		result = -EFAULT;
+		goto unlock;
+	}
+
+	complete(&painter->ddcci_response_received);
+
+unlock:
+	painter_unlock(painter);
+	return result;
+}
diff -ruN a/drivers/gpu/drm/evdi/evdi_stats.c b/drivers/gpu/drm/evdi/evdi_stats.c
--- a/drivers/gpu/drm/evdi/evdi_stats.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/evdi_stats.c	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2015 - 2016 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include "evdi_drv.h"
+
+static ssize_t frame_count_show(struct device *dev,
+				__always_unused struct device_attribute *attr,
+				char *buf)
+{
+	struct drm_minor *drm_minor = dev_get_drvdata(dev);
+	struct drm_device *drm_dev = drm_minor->dev;
+	struct evdi_device *evdi = drm_dev->dev_private;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			atomic_read(&evdi->frame_count));
+}
+
+static struct device_attribute evdi_device_attributes[] = {
+	__ATTR_RO(frame_count),
+};
+
+void evdi_stats_init(struct evdi_device *evdi)
+{
+	int i, retval;
+
+	DRM_INFO("evdi: %s\n", __func__);
+	atomic_set(&evdi->frame_count, 0);
+	for (i = 0; i < ARRAY_SIZE(evdi_device_attributes); i++) {
+		retval =
+		    device_create_file(evdi->ddev->primary->kdev,
+				       &evdi_device_attributes[i]);
+		if (retval)
+			DRM_ERROR("evdi: device_create_file failed %d\n",
+				  retval);
+	}
+}
+
+void evdi_stats_cleanup(struct evdi_device *evdi)
+{
+	int i;
+
+	DRM_INFO("evdi: %s\n", __func__);
+
+	for (i = 0; i < ARRAY_SIZE(evdi_device_attributes); i++)
+		device_remove_file(evdi->ddev->primary->kdev,
+				   &evdi_device_attributes[i]);
+}
diff -ruN a/drivers/gpu/drm/evdi/Kconfig b/drivers/gpu/drm/evdi/Kconfig
--- a/drivers/gpu/drm/evdi/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/Kconfig	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,18 @@
+#
+# Copyright (c) 2015 - 2018 DisplayLink (UK) Ltd.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License v2. See the file COPYING in the main directory of this archive for
+# more details.
+#
+
+config DRM_EVDI
+	tristate "Extensible Virtual Display Interface"
+	depends on DRM
+	select DRM_KMS_HELPER
+	help
+		This is a KMS interface driver allowing user-space programs to
+		register a virtual display (that imitates physical monitor) and
+		retrieve contents (as a frame buffer) that system renders on it.
+		Say M/Y to add support for these devices via DRM/KMS interfaces.
+
diff -ruN a/drivers/gpu/drm/evdi/Makefile b/drivers/gpu/drm/evdi/Makefile
--- a/drivers/gpu/drm/evdi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/evdi/Makefile	2021-03-14 08:27:48.000000000 +0100
@@ -0,0 +1,15 @@
+#
+# Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License v2. See the file COPYING in the main directory of this archive for
+# more details.
+#
+ccflags-y := -Iinclude/drm
+
+evdi-y := evdi_drv.o evdi_modeset.o evdi_connector.o evdi_encoder.o evdi_main.o evdi_fb.o evdi_gem.o evdi_stats.o evdi_painter.o evdi_debug.o evdi_cursor.o evdi_i2c.o
+
+evdi-$(CONFIG_COMPAT) += evdi_ioc32.o
+
+obj-$(CONFIG_DRM_EVDI) := evdi.o
+
--- a/include/uapi/drm/evdi_drm.h	2021-05-16 17:41:26.730015125 +0200
+++ b/include/uapi/drm/evdi_drm.h	2021-03-14 08:28:19.000000000 +0100
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note 
+ *
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef __UAPI_EVDI_DRM_H__
+#define __UAPI_EVDI_DRM_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#include "drm.h"
+
+/* Output events sent from driver to evdi lib */
+#define DRM_EVDI_EVENT_UPDATE_READY  0x80000000
+#define DRM_EVDI_EVENT_DPMS          0x80000001
+#define DRM_EVDI_EVENT_MODE_CHANGED  0x80000002
+#define DRM_EVDI_EVENT_CRTC_STATE    0x80000003
+#define DRM_EVDI_EVENT_CURSOR_SET    0x80000004
+#define DRM_EVDI_EVENT_CURSOR_MOVE   0x80000005
+#define DRM_EVDI_EVENT_DDCCI_DATA    0x80000006
+
+struct drm_evdi_event_update_ready {
+	struct drm_event base;
+};
+
+struct drm_evdi_event_dpms {
+	struct drm_event base;
+	int32_t mode;
+};
+
+struct drm_evdi_event_mode_changed {
+	struct drm_event base;
+	int32_t hdisplay;
+	int32_t vdisplay;
+	int32_t vrefresh;
+	int32_t bits_per_pixel;
+	uint32_t pixel_format;
+};
+
+struct drm_evdi_event_crtc_state {
+	struct drm_event base;
+	int32_t state;
+};
+
+struct drm_evdi_connect {
+	int32_t connected;
+	int32_t dev_index;
+	const unsigned char * __user edid;
+	uint32_t edid_length;
+	uint32_t sku_area_limit;
+};
+
+struct drm_evdi_request_update {
+	int32_t reserved;
+};
+
+enum drm_evdi_grabpix_mode {
+	EVDI_GRABPIX_MODE_RECTS = 0,
+	EVDI_GRABPIX_MODE_DIRTY = 1,
+};
+
+struct drm_evdi_grabpix {
+	enum drm_evdi_grabpix_mode mode;
+	int32_t buf_width;
+	int32_t buf_height;
+	int32_t buf_byte_stride;
+	unsigned char __user *buffer;
+	int32_t num_rects;
+	struct drm_clip_rect __user *rects;
+};
+
+struct drm_evdi_event_cursor_set {
+	struct drm_event base;
+	int32_t hot_x;
+	int32_t hot_y;
+	uint32_t width;
+	uint32_t height;
+	uint8_t enabled;
+	uint32_t buffer_handle;
+	uint32_t buffer_length;
+	uint32_t pixel_format;
+	uint32_t stride;
+};
+
+struct drm_evdi_event_cursor_move {
+	struct drm_event base;
+	int32_t x;
+	int32_t y;
+};
+
+struct drm_evdi_ddcci_response {
+	const unsigned char * __user buffer;
+	uint32_t buffer_length;
+	uint8_t result;
+};
+
+#define DDCCI_BUFFER_SIZE 64
+
+struct drm_evdi_event_ddcci_data {
+	struct drm_event base;
+	unsigned char buffer[DDCCI_BUFFER_SIZE];
+	uint32_t buffer_length;
+	uint16_t flags;
+	uint16_t address;
+};
+
+/* Input ioctls from evdi lib to driver */
+#define DRM_EVDI_CONNECT          0x00
+#define DRM_EVDI_REQUEST_UPDATE   0x01
+#define DRM_EVDI_GRABPIX          0x02
+#define DRM_EVDI_DDCCI_RESPONSE   0x03
+/* LAST_IOCTL 0x5F -- 96 driver specific ioctls to use */
+
+#define DRM_IOCTL_EVDI_CONNECT DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_CONNECT, struct drm_evdi_connect)
+#define DRM_IOCTL_EVDI_REQUEST_UPDATE DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_REQUEST_UPDATE, struct drm_evdi_request_update)
+#define DRM_IOCTL_EVDI_GRABPIX DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_GRABPIX, struct drm_evdi_grabpix)
+#define DRM_IOCTL_EVDI_DDCCI_RESPONSE DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_DDCCI_RESPONSE, struct drm_evdi_ddcci_response)
+
+#endif /* __EVDI_UAPI_DRM_H__ */
+
