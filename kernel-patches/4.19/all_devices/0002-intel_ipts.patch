diff -ruN a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
--- a/drivers/gpu/drm/i915/i915_drv.h	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/gpu/drm/i915/i915_drv.h	2019-11-01 16:57:47.332705561 +0100
@@ -61,6 +61,9 @@
 #include "intel_device_info.h"
 #include "intel_display.h"
 #include "intel_dpll_mgr.h"
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+#include "intel_ipts.h"
+#endif
 #include "intel_lrc.h"
 #include "intel_opregion.h"
 #include "intel_ringbuffer.h"
diff -ruN a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
--- a/drivers/gpu/drm/i915/i915_gem.c	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/gpu/drm/i915/i915_gem.c	2019-11-01 17:04:57.429270201 +0100
@@ -5053,6 +5053,11 @@
 
 	mutex_lock(&i915->drm.struct_mutex);
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION && intel_ipts.to_i915)
+		intel_ipts_guc_submission_disable();
+#endif
+
 	/*
 	 * We have to flush all the executing contexts to main memory so
 	 * that they can saved in the hibernation image. To ensure the last
@@ -5177,6 +5182,11 @@
 	if (i915_gem_switch_to_kernel_context(i915))
 		goto err_wedged;
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION && intel_ipts.to_i915)
+		intel_ipts_guc_submission_enable();
+#endif
+
 out_unlock:
 	intel_uncore_forcewake_put(i915, FORCEWAKE_ALL);
 	mutex_unlock(&i915->drm.struct_mutex);
@@ -5552,6 +5562,11 @@
 		goto err_init_hw;
 	}
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION && intel_ipts.to_i915)
+		intel_ipts_guc_submission_enable();
+#endif
+
 	intel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
@@ -5620,6 +5635,10 @@
 	i915_gem_drain_workqueue(dev_priv);
 
 	mutex_lock(&dev_priv->drm.struct_mutex);
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION && intel_ipts.to_i915)
+		intel_ipts_guc_submission_disable();
+#endif
 	intel_uc_fini_hw(dev_priv);
 	intel_uc_fini(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
diff -ruN a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c
--- a/drivers/gpu/drm/i915/i915_irq.c	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/gpu/drm/i915/i915_irq.c	2019-11-01 16:57:47.332705561 +0100
@@ -1498,6 +1498,11 @@
 	if (iir & GT_CONTEXT_SWITCH_INTERRUPT)
 		tasklet = true;
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	if (iir & GT_RENDER_PIPECTL_NOTIFY_INTERRUPT)
+		intel_ipts_notify_handle_processed_data();
+#endif
+
 	if (iir & GT_RENDER_USER_INTERRUPT) {
 		notify_ring(engine);
 		tasklet |= USES_GUC_SUBMISSION(engine->i915);
@@ -4138,6 +4143,10 @@
 	if (HAS_L3_DPF(dev_priv))
 		gt_interrupts[0] |= GT_RENDER_L3_PARITY_ERROR_INTERRUPT;
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+		gt_interrupts[0] |= GT_RENDER_PIPECTL_NOTIFY_INTERRUPT << GEN8_RCS_IRQ_SHIFT;
+#endif
+
 	dev_priv->pm_ier = 0x0;
 	dev_priv->pm_imr = ~dev_priv->pm_ier;
 	GEN8_IRQ_INIT_NDX(GT, 0, ~gt_interrupts[0], gt_interrupts[0]);
diff -ruN a/drivers/gpu/drm/i915/intel_guc_submission.c b/drivers/gpu/drm/i915/intel_guc_submission.c
--- a/drivers/gpu/drm/i915/intel_guc_submission.c	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/gpu/drm/i915/intel_guc_submission.c	2019-11-01 17:06:26.610099021 +0100
@@ -357,6 +357,11 @@
 
 	desc->attribute = GUC_STAGE_DESC_ATTR_ACTIVE |
 			  GUC_STAGE_DESC_ATTR_KERNEL;
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	if (client->engines == RENDER_RING)
+		desc->attribute = GUC_STAGE_DESC_ATTR_ACTIVE |
+				  GUC_STAGE_DESC_ATTR_PCH;
+#endif
 	if (is_high_priority(client))
 		desc->attribute |= GUC_STAGE_DESC_ATTR_PREEMPT;
 	desc->stage_id = client->stage_id;
@@ -1206,6 +1211,10 @@
 	/* route USER_INTERRUPT to Host, all others are sent to GuC. */
 	irqs = GT_RENDER_USER_INTERRUPT << GEN8_RCS_IRQ_SHIFT |
 	       GT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT;
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	irqs |= GT_RENDER_PIPECTL_NOTIFY_INTERRUPT << GEN8_RCS_IRQ_SHIFT;
+#endif
+
 	/* These three registers have the same bit definitions */
 	I915_WRITE(GUC_BCS_RCS_IER, ~irqs);
 	I915_WRITE(GUC_VCS2_VCS1_IER, ~irqs);
@@ -1349,6 +1358,75 @@
 	guc_clients_doorbell_fini(guc);
 }
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+int intel_ipts_guc_submission_enable(void)
+{
+	struct i915_gem_context *gem_context;
+	int ret = 0;
+
+	gem_context = i915_gem_context_create_kernel(intel_ipts.to_i915, I915_PRIORITY_NORMAL);
+	if (IS_ERR(gem_context)) {
+		ret = PTR_ERR(gem_context);
+		DRM_ERROR("IPTS: Failed to create IPTS context (error %d)\n", ret);
+		return ret;
+	}
+
+	intel_ipts.ipts_context = intel_context_pin(gem_context, intel_ipts.to_i915->engine[RCS]);
+	if (ret) {
+		DRM_ERROR("IPTS: Context pin failed : %d\n", ret);
+		i915_gem_context_put(gem_context);
+		intel_ipts.ipts_context = NULL;
+		return ret;
+	}
+
+	intel_ipts.ipts_client = guc_client_alloc(intel_ipts.to_i915,
+				  		  RENDER_RING,
+				  		  GUC_CLIENT_PRIORITY_NORMAL,
+				  		  intel_ipts.ipts_context->gem_context);
+	if (IS_ERR(intel_ipts.ipts_client)) {
+		DRM_ERROR("IPTS: Failed to create IPTS GUC client!\n");
+		ret = PTR_ERR(intel_ipts.ipts_client);
+		goto err_client;
+	}
+
+	ret = create_doorbell(intel_ipts.ipts_client);
+	if (ret) {
+		DRM_ERROR("IPTS: Failed to create IPTS GUC doorbell!\n");
+		goto err_doorbell;
+	}
+
+	intel_ipts.initialized = true;
+
+	return 0;
+
+err_doorbell:
+	guc_client_free(intel_ipts.ipts_client);
+	intel_ipts.ipts_client = NULL;
+
+err_client:
+	intel_context_unpin(intel_ipts.ipts_context);
+	intel_ipts.ipts_context = NULL;
+
+	return ret;
+}
+
+void intel_ipts_guc_submission_disable(void)
+{
+	if (!intel_ipts.initialized)
+		return;
+
+	intel_ipts.initialized = false;
+
+	destroy_doorbell(intel_ipts.ipts_client);
+
+	guc_client_free(intel_ipts.ipts_client);
+	intel_ipts.ipts_client = NULL;
+
+	intel_context_unpin(intel_ipts.ipts_context);
+	intel_ipts.ipts_context = NULL;
+}
+#endif
+
 #if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
 #include "selftests/intel_guc.c"
 #endif
diff -ruN a/drivers/gpu/drm/i915/intel_ipts.c b/drivers/gpu/drm/i915/intel_ipts.c
--- a/drivers/gpu/drm/i915/intel_ipts.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/i915/intel_ipts.c	2019-11-01 16:57:47.332705561 +0100
@@ -0,0 +1,191 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include "intel_guc_submission.h"
+#include "i915_drv.h"
+
+ipts_i915_t intel_ipts;
+
+int intel_ipts_map_buffer(ipts_mapbuffer_t *mapbuf)
+{
+	struct drm_i915_gem_object *gem_obj = NULL;
+	struct i915_vma *vma = NULL;
+	ipts_object_t *obj = NULL;
+	int ret = 0;
+
+	obj = kzalloc(sizeof(ipts_object_t), GFP_KERNEL);
+	if (!obj) {
+		DRM_ERROR("intel_ipts: Failed creating buffer\n");
+		return -ENOMEM;
+	}
+
+	gem_obj = i915_gem_object_create(intel_ipts.to_i915, roundup(mapbuf->size, PAGE_SIZE));
+	if (gem_obj == NULL) {
+		DRM_ERROR("intel_ipts: Failed creating GEM object\n");
+		ret = -ENOMEM;
+		goto err_obj;
+	}
+	obj->gem_obj = gem_obj;
+
+	if (mapbuf->flags & 0x01) {
+		ret = i915_gem_object_attach_phys(gem_obj, PAGE_SIZE);
+		if (ret) {
+			DRM_ERROR("intel_ipts: Failed attaching GEM object : %d\n", ret);
+			goto err_gem;
+		}
+		obj->cpu_addr = gem_obj->phys_handle->vaddr;
+	}
+
+	vma = i915_vma_instance(gem_obj, &intel_ipts.ipts_context->gem_context->ppgtt->vm, NULL);
+	if (IS_ERR(vma)) {
+		ret = PTR_ERR(vma);
+		DRM_ERROR("intel_ipts: Failed creating VMA\n");
+		goto err_gem;
+	}
+	obj->vma = vma;
+
+	ret = i915_vma_pin(vma, 0, PAGE_SIZE, PIN_USER);
+	if (ret) {
+		DRM_ERROR("intel_ipts: Failed pinning VMA\n");
+		goto err_vma_close;
+	}
+
+	if (!gem_obj->phys_handle) {
+		obj->cpu_addr = i915_gem_object_pin_map(gem_obj, I915_MAP_WB);
+		if (IS_ERR(obj->cpu_addr)) {
+			ret = PTR_ERR(obj->cpu_addr);
+			DRM_ERROR("intel_ipts: Failed pinning GEM object : %d\n", ret);
+			goto err_vma_unpin;
+		}
+	}
+
+	mapbuf->buf_handle = (u64)obj;
+	mapbuf->cpu_addr = (void*)obj->cpu_addr;
+	mapbuf->gfx_addr = (void*)vma->node.start;
+	mapbuf->phy_addr = (obj->gem_obj->phys_handle) ? (u64)obj->gem_obj->phys_handle->busaddr : 0;
+
+	spin_lock(&intel_ipts.buffers.lock);
+	list_add_tail(&obj->list, &intel_ipts.buffers.list);
+	spin_unlock(&intel_ipts.buffers.lock);
+
+	return 0;
+
+err_vma_unpin:
+	i915_vma_unpin(obj->vma);
+
+err_vma_close:
+	i915_vma_close(obj->vma);
+
+err_gem:
+	i915_gem_object_put(obj->gem_obj);
+
+err_obj:
+	kfree(obj);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(intel_ipts_map_buffer);
+
+int intel_ipts_unmap_buffer(uint64_t buf_handle)
+{
+	ipts_object_t* obj = (ipts_object_t*)buf_handle;
+
+	spin_lock(&intel_ipts.buffers.lock);
+	list_del(&obj->list);
+	spin_unlock(&intel_ipts.buffers.lock);
+
+	if (!obj->gem_obj->phys_handle)
+		i915_gem_object_unpin_pages(obj->gem_obj);
+	
+	i915_vma_unpin(obj->vma);
+
+	i915_vma_close(obj->vma);
+
+	i915_gem_object_put(obj->gem_obj);
+
+	kfree(obj);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(intel_ipts_unmap_buffer);
+
+static void intel_ipts_get_wq_info(ipts_wq_info_t *wq_info)
+{
+	struct guc_process_desc *desc;
+	void *base = NULL;
+	u64 phy_base = 0;
+
+	base = intel_ipts.ipts_client->vaddr;
+	desc = (struct guc_process_desc *)((u64)base + intel_ipts.ipts_client->proc_desc_offset);
+
+	desc->wq_base_addr = (u64)base + GUC_DB_SIZE;
+	desc->db_base_addr = (u64)base + intel_ipts.ipts_client->doorbell_offset;
+
+	phy_base = sg_dma_address(intel_ipts.ipts_client->vma->pages->sgl);
+
+	wq_info->db_addr = desc->db_base_addr;
+	wq_info->db_phy_addr = phy_base + intel_ipts.ipts_client->doorbell_offset;
+	wq_info->db_cookie_offset = offsetof(struct guc_doorbell_info, cookie);
+	wq_info->wq_addr = desc->wq_base_addr;
+	wq_info->wq_phy_addr = phy_base + GUC_DB_SIZE;
+	wq_info->wq_head_addr = (u64)&desc->head;
+	wq_info->wq_head_phy_addr = phy_base + intel_ipts.ipts_client->proc_desc_offset +
+					offsetof(struct guc_process_desc, head);
+	wq_info->wq_tail_addr = (u64)&desc->tail;
+	wq_info->wq_tail_phy_addr = phy_base + intel_ipts.ipts_client->proc_desc_offset +
+					offsetof(struct guc_process_desc, tail);
+	wq_info->wq_size = desc->wq_size_bytes;
+}
+
+static void raw_data_work_func(struct work_struct *work)
+{
+	if (intel_ipts.handle_processed_data)
+		intel_ipts.handle_processed_data(intel_ipts.ipts);
+}
+
+void intel_ipts_notify_handle_processed_data(void)
+{
+	if (intel_ipts.ipts && intel_ipts.ipts->state == IPTS_STA_RAW_DATA_STARTED)
+		schedule_work(&intel_ipts.raw_data_work);
+}
+
+int intel_ipts_connect(ipts_info_t *ipts, void *intel_ipts_handle_processed_data)
+{
+	if (!intel_ipts.initialized)
+		return -ENODEV;
+
+	intel_ipts.ipts = ipts;
+	intel_ipts.ipts->hardware_id = intel_ipts.hardware_id;
+	intel_ipts.handle_processed_data = intel_ipts_handle_processed_data;
+
+	intel_ipts_get_wq_info(&intel_ipts.ipts->resources.wq_info);
+
+	INIT_WORK(&intel_ipts.raw_data_work, raw_data_work_func);
+
+	spin_lock_init(&intel_ipts.buffers.lock);
+	INIT_LIST_HEAD(&intel_ipts.buffers.list);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(intel_ipts_connect);
+
+void intel_ipts_disconnect(void)
+{
+	destroy_work_on_stack(&intel_ipts.raw_data_work);
+
+	intel_ipts.handle_processed_data = NULL;
+	intel_ipts.ipts = NULL;
+}
+EXPORT_SYMBOL_GPL(intel_ipts_disconnect);
diff -ruN a/drivers/gpu/drm/i915/intel_ipts.h b/drivers/gpu/drm/i915/intel_ipts.h
--- a/drivers/gpu/drm/i915/intel_ipts.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/i915/intel_ipts.h	2019-11-01 16:57:47.336705593 +0100
@@ -0,0 +1,51 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _INTEL_IPTS_H_
+#define _INTEL_IPTS_H_
+
+#include <linux/intel-ipts.h>
+
+struct drm_i915_private;
+
+typedef struct ipts_object {
+	struct list_head list;
+	struct drm_i915_gem_object *gem_obj;
+	struct i915_vma *vma;
+	void	*cpu_addr;
+} ipts_object_t;
+
+typedef struct ipts_i915 {
+	struct drm_i915_private *to_i915;
+	struct intel_guc_client *ipts_client;
+	struct intel_context *ipts_context;
+	struct {
+		spinlock_t       lock;
+		struct list_head list;
+	} buffers;
+	ipts_info_t *ipts;
+	bool initialized;
+	char hardware_id[10];
+	struct work_struct raw_data_work;
+	void (*handle_processed_data)(ipts_info_t *ipts);
+} ipts_i915_t;
+
+extern ipts_i915_t intel_ipts;
+
+void intel_ipts_notify_handle_processed_data(void);
+int intel_ipts_guc_submission_enable(void);
+void intel_ipts_guc_submission_disable(void);
+
+#endif // _INTEL_IPTS_IF_H_
diff -ruN a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c
--- a/drivers/gpu/drm/i915/intel_lrc.c	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/gpu/drm/i915/intel_lrc.c	2019-11-01 16:57:47.336705593 +0100
@@ -2384,6 +2384,9 @@
 
 	engine->irq_enable_mask = GT_RENDER_USER_INTERRUPT << shift;
 	engine->irq_keep_mask = GT_CONTEXT_SWITCH_INTERRUPT << shift;
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	engine->irq_keep_mask |= GT_RENDER_PIPECTL_NOTIFY_INTERRUPT << shift;
+#endif
 }
 
 static void
--- a/drivers/gpu/drm/i915/intel_uc.c	2020-04-13 05:26:04.000000000 +0200
+++ b/drivers/gpu/drm/i915/intel_uc.c	2020-04-13 11:07:26.618307053 +0200
@@ -84,6 +84,35 @@
 	return guc_log_level;
 }
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+void intel_ipts_detect(struct drm_i915_private *i915)
+{
+	acpi_handle handle;
+	acpi_status status;
+	struct acpi_device_info *device_info;
+
+	status = acpi_get_handle(ACPI_ROOT_OBJECT, "\\_SB.TSML", &handle);
+	if (ACPI_FAILURE(status))
+		return;
+
+	status = acpi_get_object_info(handle, &device_info);
+	if (ACPI_FAILURE(status))
+		return;
+
+	if (!strncmp(device_info->hardware_id.string, "MSHW0076", 8) ||
+	    !strncmp(device_info->hardware_id.string, "MSHW0078", 8) ||
+	    !strncmp(device_info->hardware_id.string, "MSHW0079", 8) ||
+	    !strncmp(device_info->hardware_id.string, "MSHW0101", 8) ||
+	    !strncmp(device_info->hardware_id.string, "MSHW0102", 8) ||
+	    !strncmp(device_info->hardware_id.string, "MSHW0103", 8) ||
+	    !strncmp(device_info->hardware_id.string, "MSHW0137", 8)) {
+			intel_ipts.to_i915 = i915;
+			i915_modparams.enable_guc = -1;
+			snprintf(intel_ipts.hardware_id, sizeof(intel_ipts.hardware_id), "%s", device_info->hardware_id.string);
+	}
+}
+#endif
+
 /**
  * sanitize_options_early - sanitize uC related modparam options
  * @i915: device private
@@ -106,6 +129,10 @@
 	struct intel_uc_fw *guc_fw = &i915->guc.fw;
 	struct intel_uc_fw *huc_fw = &i915->huc.fw;
 
+#if IS_ENABLED(CONFIG_INTEL_IPTS)
+	intel_ipts_detect(i915);
+#endif
+
 	/* A negative value means "use platform default" */
 	if (i915_modparams.enable_guc < 0)
 		i915_modparams.enable_guc = __get_platform_enable_guc(i915);
diff -ruN a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
--- a/drivers/gpu/drm/i915/Makefile	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/gpu/drm/i915/Makefile	2019-11-01 16:57:47.336705593 +0100
@@ -155,6 +155,9 @@
 	  vlv_dsi.o \
 	  vlv_dsi_pll.o
 
+# Intel Precise Touch & Stylus
+i915-$(CONFIG_INTEL_IPTS)  += intel_ipts.o
+
 # Post-mortem debug and GPU hang state capture
 i915-$(CONFIG_DRM_I915_CAPTURE_ERROR) += i915_gpu_error.o
 i915-$(CONFIG_DRM_I915_SELFTEST) += \
diff -ruN a/drivers/misc/ipts/hid.c b/drivers/misc/ipts/hid.c
--- a/drivers/misc/ipts/hid.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/hid.c	2019-11-01 16:57:47.336705593 +0100
@@ -0,0 +1,202 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/firmware.h>
+#include <linux/intel-ipts.h>
+
+#include "hid.h"
+#include "msgs.h"
+
+static int ipts_hid_get_hid_descriptor(ipts_info_t *ipts, u8 **desc, int *size)
+{
+	u8 *buf;
+	int hid_size = 0, ret = 0;
+	const struct firmware *vendor_desc = NULL;
+	char fw_path[256];
+
+	if (!strcmp(ipts->hardware_id, "MSHW0079"))
+		snprintf(fw_path, 256, "intel/ipts/SurfaceTouchServicingDescriptor%s.bin", "MSHW0137");	
+	else
+		snprintf(fw_path, 256, "intel/ipts/SurfaceTouchServicingDescriptor%s.bin", ipts->hardware_id);
+	ret = request_firmware(&vendor_desc, fw_path, &ipts->cldev->dev);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "error in reading HID Vendor Descriptor\n");
+		return ret;
+	}
+
+	hid_size = vendor_desc->size;
+	dev_dbg(&ipts->cldev->dev, "hid size = %d\n", hid_size);
+	buf = vmalloc(hid_size);
+	if (buf == NULL) {
+		ret = -ENOMEM;
+		goto no_mem;
+	}
+
+	memcpy(buf, vendor_desc->data, vendor_desc->size);
+	release_firmware(vendor_desc);
+
+	*desc = buf;
+	*size = hid_size;
+
+	return 0;
+no_mem :
+	if (vendor_desc)
+		release_firmware(vendor_desc);
+
+	return ret;
+}
+
+static int ipts_hid_parse(struct hid_device *hid)
+{
+	ipts_info_t *ipts = hid->driver_data;
+	int ret = 0, size;
+	u8 *buf;
+
+	dev_dbg(&ipts->cldev->dev, "ipts_hid_parse() start\n");
+	ret = ipts_hid_get_hid_descriptor(ipts, &buf, &size);
+	if (ret != 0) {
+		dev_err(&ipts->cldev->dev, "ipts_hid_ipts_get_hid_descriptor ret %d\n", ret);
+		return -EIO;
+	}
+
+	ret = hid_parse_report(hid, buf, size);
+	vfree(buf);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "hid_parse_report error : %d\n", ret);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int ipts_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void ipts_hid_stop(struct hid_device *hid)
+{
+	return;
+}
+
+static int ipts_hid_open(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void ipts_hid_close(struct hid_device *hid)
+{
+	return;
+}
+
+static int ipts_hid_raw_request(struct hid_device *hid,
+				unsigned char report_number, __u8 *buf,
+				size_t count, unsigned char report_type,
+				int reqtype)
+{
+	ipts_info_t *ipts = hid->driver_data;
+	u32 fb_data_type;
+
+	dev_dbg(&ipts->cldev->dev, "hid raw request => report %d, request %d\n",
+						 (int)report_type, reqtype);
+
+	if (report_type != HID_FEATURE_REPORT)
+		return 0;
+
+	switch (reqtype) {
+		case HID_REQ_GET_REPORT:
+			fb_data_type = TOUCH_FEEDBACK_DATA_TYPE_GET_FEATURES;
+			break;
+		case HID_REQ_SET_REPORT:
+			fb_data_type = TOUCH_FEEDBACK_DATA_TYPE_SET_FEATURES;
+			break;
+		default:
+			dev_err(&ipts->cldev->dev, "raw request not supprted: %d\n", reqtype);
+			return -EIO;
+	}
+
+	return ipts_hid_send_hid2me_feedback(ipts, fb_data_type, buf, count);
+}
+
+static int ipts_hid_output_report(struct hid_device *hid,
+					__u8 *buf, size_t count)
+{
+	ipts_info_t *ipts = hid->driver_data;
+	u32 fb_data_type;
+
+	dev_dbg(&ipts->cldev->dev, "hid output report\n");
+
+	fb_data_type = TOUCH_FEEDBACK_DATA_TYPE_OUTPUT_REPORT;
+
+	return ipts_hid_send_hid2me_feedback(ipts, fb_data_type, buf, count);
+}
+
+static struct hid_ll_driver ipts_hid_ll_driver = {
+	.parse = ipts_hid_parse,
+	.start = ipts_hid_start,
+	.stop = ipts_hid_stop,
+	.open = ipts_hid_open,
+	.close = ipts_hid_close,
+	.raw_request = ipts_hid_raw_request,
+	.output_report = ipts_hid_output_report,
+};
+
+int ipts_hid_init(ipts_info_t *ipts)
+{
+	int ret = 0;
+	struct hid_device *hid;
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		ret = PTR_ERR(hid);
+		goto err_dev;
+	}
+
+	hid->driver_data = ipts;
+	hid->ll_driver = &ipts_hid_ll_driver;
+	hid->dev.parent = &ipts->cldev->dev;
+	hid->bus = 0x44; // MEI
+	hid->version = ipts->device_info.fw_rev;
+	hid->vendor = ipts->device_info.vendor_id;
+	hid->product = ipts->device_info.device_id;
+
+	snprintf(hid->name, sizeof(hid->name), "%s", "Intel Precision Touch and Stylus");
+	strlcpy(hid->phys, dev_name(&ipts->cldev->dev), sizeof(hid->phys));
+
+	ret = hid_add_device(hid);
+	if (ret) {
+		if (ret != -ENODEV)
+			dev_err(&ipts->cldev->dev, "can't add hid device: %d\n", ret);
+		goto err_mem_free;
+	}
+
+	ipts->hid = hid;
+
+	return 0;
+
+err_mem_free:
+	hid_destroy_device(hid);
+err_dev:
+	return ret;
+}
+
+void ipts_hid_fini(ipts_info_t *ipts)
+{
+	if (ipts->hid) {
+		hid_destroy_device(ipts->hid);
+		ipts->hid = NULL;
+	}
+}
diff -ruN a/drivers/misc/ipts/hid.h b/drivers/misc/ipts/hid.h
--- a/drivers/misc/ipts/hid.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/hid.h	2019-11-01 16:57:47.336705593 +0100
@@ -0,0 +1,32 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _IPTS_HID_H_
+#define	_IPTS_HID_H_
+
+typedef enum touch_feedback_data_types
+{
+	TOUCH_FEEDBACK_DATA_TYPE_FEEDBACK = 0,
+	TOUCH_FEEDBACK_DATA_TYPE_SET_FEATURES,
+	TOUCH_FEEDBACK_DATA_TYPE_GET_FEATURES,
+	TOUCH_FEEDBACK_DATA_TYPE_OUTPUT_REPORT,
+	TOUCH_FEEDBACK_DATA_TYPE_STORE_DATA,
+	TOUCH_FEEDBACK_DATA_TYPE_MAX
+} touch_feedback_data_types_t;
+
+int ipts_hid_init(ipts_info_t *ipts);
+void ipts_hid_fini(ipts_info_t *ipts);
+
+#endif // _IPTS_HID_H_
diff -ruN a/drivers/misc/ipts/Kconfig b/drivers/misc/ipts/Kconfig
--- a/drivers/misc/ipts/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/Kconfig	2019-11-01 16:57:47.336705593 +0100
@@ -0,0 +1,5 @@
+config INTEL_IPTS
+	tristate "Intel Precise Touch & Stylus"
+	depends on DRM_I915 && HID && INTEL_MEI_ME
+	help
+	  Intel Precise Touch & Stylus support
diff -ruN a/drivers/misc/ipts/main.c b/drivers/misc/ipts/main.c
--- a/drivers/misc/ipts/main.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/main.c	2019-11-01 16:57:47.336705593 +0100
@@ -0,0 +1,179 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/intel-ipts.h>
+#include <linux/module.h>
+
+#include "msgs.h"
+
+static ssize_t device_info_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ipts_info_t *ipts;
+
+	ipts = dev_get_drvdata(dev);
+	return sprintf(buf,	"hardware_id = %s\n"
+				"vendor_id = 0x%04hX\n"
+				"device_id = 0x%04hX\n"
+				"hw_rev = %d\n"
+				"fw_rev = %d\n"
+				"frame_size = %d\n"
+				"feedback_size = %d\n"
+				"sensor_mode = %d\n"
+				"max_touch_points = %d\n"
+				"spi_frequency = %d\n"
+				"spi_io_mode = %d\n"
+				"sensor_minor_eds_rev = %d\n"
+				"sensor_major_eds_rev = %d\n"
+				"me_minor_eds_rev = %d\n"
+				"me_major_eds_rev = %d\n"
+				"sensor_eds_intf_rev = %d\n"
+				"me_eds_intf_rev = %d\n"
+				"kernel_compat_ver = %d\n",
+				ipts->hardware_id,
+				ipts->device_info.vendor_id,
+				ipts->device_info.device_id,
+				ipts->device_info.hw_rev,
+				ipts->device_info.fw_rev,
+				ipts->device_info.frame_size,
+				ipts->device_info.feedback_size,
+				ipts->device_info.sensor_mode,
+				ipts->device_info.max_touch_points,
+				ipts->device_info.spi_frequency,
+				ipts->device_info.spi_io_mode,
+				ipts->device_info.sensor_minor_eds_rev,
+				ipts->device_info.sensor_major_eds_rev,
+				ipts->device_info.me_minor_eds_rev,
+				ipts->device_info.me_major_eds_rev,
+				ipts->device_info.sensor_eds_intf_rev,
+				ipts->device_info.me_eds_intf_rev,
+				ipts->device_info.kernel_compat_ver);
+}
+static DEVICE_ATTR_RO(device_info);
+
+static struct attribute *ipts_attrs[] = {
+	&dev_attr_device_info.attr,
+	NULL
+};
+
+static const struct attribute_group ipts_grp = {
+	.attrs = ipts_attrs,
+};
+
+static void mei_ipts_rx(struct mei_cl_device *cldev)
+{
+	ipts_info_t *ipts = mei_cldev_get_drvdata(cldev);
+
+	ssize_t msg_len;
+	touch_sensor_msg_m2h_t m2h_msg;
+
+	if (ipts->state != IPTS_STA_STOPPING) {
+		msg_len = mei_cldev_recv(cldev, (u8*)&m2h_msg, sizeof(m2h_msg));
+		if (msg_len <= 0) {
+			dev_err(&cldev->dev, "error in reading m2h msg\n");
+			return;
+		}
+
+		if (ipts_handle_resp(ipts, &m2h_msg, msg_len) != 0) {
+			dev_err(&cldev->dev, "error in handling resp msg\n");
+		}
+	}
+}
+
+static int ipts_mei_cl_probe(struct mei_cl_device *cldev, const struct mei_cl_device_id *id)
+{
+	int ret = 0;
+	ipts_info_t *ipts;
+
+	dev_info(&cldev->dev, "IPTS started");
+
+	if (dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64)) == 0) {
+		dev_dbg(&cldev->dev, "Using DMA_BIT_MASK(64)\n");
+	} else if (dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32)) == 0) {
+		dev_dbg(&cldev->dev, "Using DMA_BIT_MASK(32)\n");
+	} else {
+		dev_err(&cldev->dev, "No suitable DMA available\n");
+		return -EFAULT;
+	}
+
+	ipts = devm_kzalloc(&cldev->dev, sizeof(ipts_info_t), GFP_KERNEL);
+	if (ipts == NULL) {
+		dev_err(&cldev->dev, "Cannot allocate IPTS object\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ipts->cldev = cldev;
+
+	mei_cldev_set_drvdata(cldev, ipts);
+
+	ret = mei_cldev_enable(cldev);
+	if (ret < 0) {
+		dev_err(&cldev->dev, "Cannot enable mei device\n");
+		return ret;
+	}
+
+	ret = mei_cldev_register_rx_cb(cldev, mei_ipts_rx);
+	if (ret) {
+		dev_err(&cldev->dev, "Could not reg rx event ret=%d\n", ret);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&ipts->cldev->dev.kobj, &ipts_grp);
+	if (ret)
+		dev_err(&cldev->dev, "Cannot create sysfs for IPTS\n");
+
+	ret = ipts_start(ipts);
+	if (ret) {
+		dev_err(&cldev->dev, "Cannot start IPTS\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ipts_mei_cl_remove(struct mei_cl_device *cldev)
+{
+	ipts_info_t *ipts = mei_cldev_get_drvdata(cldev);
+
+	ipts_stop(ipts);
+	sysfs_remove_group(&cldev->dev.kobj, &ipts_grp);
+	mei_cldev_disable(cldev);
+
+	dev_info(&cldev->dev, "IPTS removed");
+
+	return 0;
+}
+
+static struct mei_cl_device_id ipts_mei_cl_tbl[] = {
+	{ .uuid = UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94, 0x02, 0xae, 0x04), .version = MEI_CL_VERSION_ANY },
+	{ }
+};
+MODULE_DEVICE_TABLE(mei, ipts_mei_cl_tbl);
+
+static struct mei_cl_driver ipts_mei_cl_driver = {
+	.id_table = ipts_mei_cl_tbl,
+	.name = KBUILD_MODNAME,
+	.probe = ipts_mei_cl_probe,
+	.remove = ipts_mei_cl_remove,
+};
+
+module_mei_cl_driver(ipts_mei_cl_driver);
+
+MODULE_DESCRIPTION
+	("Intel(R) Management Engine Interface Client Driver for "\
+	"Intel Precision Touch and Stylus");
+MODULE_LICENSE("GPL");
diff -ruN a/drivers/misc/ipts/Makefile b/drivers/misc/ipts/Makefile
--- a/drivers/misc/ipts/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/Makefile	2019-11-01 16:57:47.336705593 +0100
@@ -0,0 +1,6 @@
+intel-ipts-objs += hid.o
+intel-ipts-objs += main.o
+intel-ipts-objs += msgs.o
+intel-ipts-objs += resources.o
+
+obj-$(CONFIG_INTEL_IPTS)+= intel-ipts.o
diff -ruN a/drivers/misc/ipts/msgs.c b/drivers/misc/ipts/msgs.c
--- a/drivers/misc/ipts/msgs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/msgs.c	2020-03-05 07:29:50.877525327 +0100
@@ -0,0 +1,500 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/intel-ipts.h>
+#include <linux/moduleparam.h>
+
+#include "hid.h"
+#include "msgs.h"
+#include "resources.h"
+
+static bool no_feedback = false;
+module_param(no_feedback, bool, 0644);
+MODULE_PARM_DESC(no_feedback,
+				"Disable feedback for SP4 and SB1 users experiencing touch input crashes. "
+				"(default: false)");
+
+static int ipts_handle_cmd(ipts_info_t *ipts, u32 cmd, void *data, int data_size)
+{
+	int ret = 0;
+	touch_sensor_msg_h2m_t h2m_msg;
+	int len = 0;
+
+	memset(&h2m_msg, 0, sizeof(h2m_msg));
+
+	h2m_msg.command_code = cmd;
+	len = sizeof(h2m_msg.command_code) + data_size;
+	if (data != NULL && data_size != 0)
+		memcpy(&h2m_msg.h2m_data, data, data_size);
+
+	ret = mei_cldev_send(ipts->cldev, (u8*)&h2m_msg, len);
+	if (ret < 0) {
+		dev_err(&ipts->cldev->dev, "mei_cldev_send() error 0x%X:%d\n",
+							cmd, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ipts_send_sensor_quiesce_io_cmd(ipts_info_t *ipts)
+{
+	int ret;
+	int cmd_len;
+	touch_sensor_quiesce_io_cmd_data_t quiesce_io_cmd;
+
+	cmd_len = sizeof(touch_sensor_quiesce_io_cmd_data_t);
+	memset(&quiesce_io_cmd, 0, cmd_len);
+
+	ret = ipts_handle_cmd(ipts, TOUCH_SENSOR_QUIESCE_IO_CMD,
+				&quiesce_io_cmd, cmd_len);
+
+	return ret;
+}
+
+static int ipts_send_sensor_hid_ready_for_data_cmd(ipts_info_t *ipts)
+{
+	return ipts_handle_cmd(ipts, TOUCH_SENSOR_HID_READY_FOR_DATA_CMD, NULL, 0);
+}
+
+static int ipts_send_sensor_clear_mem_window_cmd(ipts_info_t *ipts)
+{
+	return ipts_handle_cmd(ipts, TOUCH_SENSOR_CLEAR_MEM_WINDOW_CMD, NULL, 0);
+}
+
+static void get_raw_data_only_smw_cmd_data(ipts_info_t *ipts,
+				touch_sensor_set_mem_window_cmd_data_t *data,
+				ipts_resources_t *resrc)
+{
+	u64 wq_tail_phy_addr;
+	u64 cookie_phy_addr;
+	ipts_buffer_info_t *touch_buf;
+	ipts_buffer_info_t *feedback_buf;
+	int i;
+
+	touch_buf = resrc->touch_data_buffer_raw;
+	feedback_buf = resrc->feedback_buffer;
+
+	for (i = 0; i < TOUCH_SENSOR_MAX_DATA_BUFFERS; i++) {
+		data->touch_data_buffer_addr_lower[i] =
+					lower_32_bits(touch_buf[i].dma_addr);
+		data->touch_data_buffer_addr_upper[i] =
+					upper_32_bits(touch_buf[i].dma_addr);
+		data->feedback_buffer_addr_lower[i] =
+					lower_32_bits(feedback_buf[i].dma_addr);
+		data->feedback_buffer_addr_upper[i] =
+					upper_32_bits(feedback_buf[i].dma_addr);
+	}
+
+	wq_tail_phy_addr = resrc->wq_info.wq_tail_phy_addr;
+	data->tail_offset_addr_lower = lower_32_bits(wq_tail_phy_addr);
+	data->tail_offset_addr_upper = upper_32_bits(wq_tail_phy_addr);
+
+	cookie_phy_addr = resrc->wq_info.db_phy_addr +
+						resrc->wq_info.db_cookie_offset;
+	data->doorbell_cookie_addr_lower = lower_32_bits(cookie_phy_addr);
+	data->doorbell_cookie_addr_upper = upper_32_bits(cookie_phy_addr);
+	data->work_queue_size = resrc->wq_info.wq_size;
+
+	data->work_queue_item_size = resrc->wq_item_size;
+}
+
+static void ipts_get_set_mem_window_cmd_data(ipts_info_t *ipts,
+				touch_sensor_set_mem_window_cmd_data_t *data)
+{
+	ipts_resources_t *resrc = &ipts->resources;
+
+	get_raw_data_only_smw_cmd_data(ipts, data, resrc);
+
+	data->hid2me_buffer_addr_lower =
+				lower_32_bits(resrc->hid2me_buffer.dma_addr);
+	data->hid2me_buffer_addr_upper =
+				upper_32_bits(resrc->hid2me_buffer.dma_addr);
+	data->hid2me_buffer_size = resrc->hid2me_buffer_size;
+}
+
+
+static int ipts_send_feedback(ipts_info_t *ipts, int buffer_idx, u32 transaction_id)
+{
+	int ret;
+	int cmd_len;
+	touch_sensor_feedback_ready_cmd_data_t fb_ready_cmd;
+
+	cmd_len = sizeof(touch_sensor_feedback_ready_cmd_data_t);
+	memset(&fb_ready_cmd, 0, cmd_len);
+
+	fb_ready_cmd.feedback_index = buffer_idx;
+	fb_ready_cmd.transaction_id = transaction_id;
+
+	ret = ipts_handle_cmd(ipts, TOUCH_SENSOR_FEEDBACK_READY_CMD,
+				&fb_ready_cmd, cmd_len);
+
+	return ret;
+}
+
+int ipts_hid_send_hid2me_feedback(ipts_info_t *ipts, u32 fb_data_type, __u8 *buf, size_t count)
+{
+	ipts_buffer_info_t *fb_buf;
+	touch_feedback_hdr_t *feedback;
+	u8 *payload;
+	int header_size;
+
+	header_size = sizeof(touch_feedback_hdr_t);
+
+	if (count > ipts->resources.hid2me_buffer_size - header_size)
+		return -EINVAL;
+
+	fb_buf = &ipts->resources.hid2me_buffer;
+	feedback = (touch_feedback_hdr_t *)fb_buf->addr;
+	payload = fb_buf->addr + header_size;
+	memset(feedback, 0, header_size);
+
+	feedback->feedback_data_type = fb_data_type;
+	feedback->feedback_cmd_type = 0;
+	feedback->payload_size_bytes = count;
+	feedback->buffer_id = TOUCH_SENSOR_MAX_DATA_BUFFERS;
+	feedback->protocol_ver = 0;
+	feedback->reserved[0] = 0xAC;
+
+	memcpy(payload, buf, count);
+
+	ipts_send_feedback(ipts, TOUCH_SENSOR_MAX_DATA_BUFFERS, 0);
+
+	return 0;
+}
+
+static int handle_outputs(ipts_info_t *ipts, int parallel_idx)
+{
+	kernel_output_buffer_header_t *out_buf_hdr;
+	ipts_buffer_info_t *output_buf, *fb_buf = NULL;
+	u8 *payload;
+	u32 transaction_id = 0;
+	int header_size, i, payload_size, ret = 0;
+
+	header_size = sizeof(kernel_output_buffer_header_t);
+	output_buf = &ipts->resources.raw_data_mode_output_buffer[parallel_idx][0];
+	for (i = 0; i < ipts->resources.num_of_outputs; i++) {
+		out_buf_hdr = (kernel_output_buffer_header_t*)output_buf[i].addr;
+		if (out_buf_hdr->length < header_size)
+			continue;
+
+		payload_size = out_buf_hdr->length - header_size;
+		payload = out_buf_hdr->data;
+
+		switch(out_buf_hdr->payload_type) {
+			case OUTPUT_BUFFER_PAYLOAD_HID_INPUT_REPORT:
+				hid_input_report(ipts->hid, HID_INPUT_REPORT,
+						payload, payload_size, 1);
+				break;
+			case OUTPUT_BUFFER_PAYLOAD_HID_FEATURE_REPORT:
+				dev_dbg(&ipts->cldev->dev, "output hid feature report\n");
+				break;
+			case OUTPUT_BUFFER_PAYLOAD_KERNEL_LOAD:
+				dev_dbg(&ipts->cldev->dev, "output kernel load\n");
+				break;
+			case OUTPUT_BUFFER_PAYLOAD_FEEDBACK_BUFFER:
+			{
+                                fb_buf = &ipts->resources.feedback_buffer[parallel_idx];
+				transaction_id = out_buf_hdr->
+						hid_private_data.transaction_id;
+				memcpy(fb_buf->addr, payload, payload_size);
+				break;
+			}
+			case OUTPUT_BUFFER_PAYLOAD_ERROR:
+			{
+				kernel_output_payload_error_t *err_payload;
+
+				if (payload_size == 0)
+					break;
+
+				err_payload =
+					(kernel_output_payload_error_t*)payload;
+
+				dev_err(&ipts->cldev->dev, "error : severity : %d,"
+						" source : %d,"
+						" code : %d:%d:%d:%d\n"
+						"string %s\n",
+						err_payload->severity,
+						err_payload->source,
+						err_payload->code[0],
+						err_payload->code[1],
+						err_payload->code[2],
+						err_payload->code[3],
+						err_payload->string);
+				
+				break;
+			}
+			default:
+				dev_err(&ipts->cldev->dev, "invalid output buffer payload\n");
+				break;
+		}
+	}
+
+	if (no_feedback)
+		return 0;
+
+	if (fb_buf)
+		ret = ipts_send_feedback(ipts, parallel_idx, transaction_id);
+
+	return ret;
+}
+
+static int handle_output_buffers(ipts_info_t *ipts, int cur_idx, int end_idx)
+{
+	do {
+		cur_idx++;
+		cur_idx %= TOUCH_SENSOR_MAX_DATA_BUFFERS;
+		handle_outputs(ipts, cur_idx);
+	} while (cur_idx != end_idx);
+
+	return 0;
+}
+
+static void ipts_handle_processed_data(ipts_info_t *ipts)
+{
+	int last_buffer_submitted = *ipts->resources.last_buffer_submitted;
+
+	if (ipts->state != IPTS_STA_RAW_DATA_STARTED || ipts->resources.last_buffer_completed == last_buffer_submitted)
+		return;
+
+	handle_output_buffers(ipts, ipts->resources.last_buffer_completed, last_buffer_submitted);
+	ipts->resources.last_buffer_completed = last_buffer_submitted;
+}
+
+static int check_validity(touch_sensor_msg_m2h_t *m2h_msg, u32 msg_len)
+{
+	int ret = 0;
+	int valid_msg_len = sizeof(m2h_msg->command_code);
+	u32 cmd_code = m2h_msg->command_code;
+
+	switch (cmd_code) {
+		case TOUCH_SENSOR_SET_MODE_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_set_mode_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_SET_MEM_WINDOW_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_set_mem_window_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_QUIESCE_IO_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_quiesce_io_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_HID_READY_FOR_DATA_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_hid_ready_for_data_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_FEEDBACK_READY_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_feedback_ready_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_CLEAR_MEM_WINDOW_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_clear_mem_window_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_NOTIFY_DEV_READY_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_notify_dev_ready_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_SET_POLICIES_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_set_policies_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_GET_POLICIES_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_get_policies_rsp_data_t);
+			break;
+		case TOUCH_SENSOR_RESET_RSP:
+			valid_msg_len +=
+				sizeof(touch_sensor_reset_rsp_data_t);
+			break;
+	}
+
+	if (valid_msg_len != msg_len) {
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+int ipts_handle_resp(ipts_info_t *ipts, touch_sensor_msg_m2h_t *m2h_msg,
+								u32 msg_len)
+{
+	int ret = 0;
+	int rsp_status = 0;
+	int cmd_len = 0;
+	u32 cmd;
+
+	if (!check_validity(m2h_msg, msg_len)) {
+		dev_err(&ipts->cldev->dev, "Wrong rsp\n");
+		return -EINVAL;
+	}
+
+	rsp_status = m2h_msg->status;
+	cmd = m2h_msg->command_code;
+
+	dev_dbg(&ipts->cldev->dev, "Cmd received 0x%08x\n", cmd);
+	switch (cmd) {
+		case TOUCH_SENSOR_NOTIFY_DEV_READY_RSP:
+		{
+			if (rsp_status != 0 && rsp_status != TOUCH_STATUS_SENSOR_FAIL_NONFATAL) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			ret = ipts_handle_cmd(ipts,
+					TOUCH_SENSOR_GET_DEVICE_INFO_CMD,
+					NULL, 0);
+			break;
+		}
+		case TOUCH_SENSOR_GET_DEVICE_INFO_RSP:
+		{
+			if (rsp_status != 0 &&
+			  rsp_status != TOUCH_STATUS_COMPAT_CHECK_FAIL) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			memcpy(&ipts->device_info,
+				&m2h_msg->m2h_data.device_info_rsp_data,
+				sizeof(touch_sensor_get_device_info_rsp_data_t));
+
+			ret = intel_ipts_connect(ipts, ipts_handle_processed_data);
+			if (ret) {
+				dev_err(&ipts->cldev->dev, "Intel i915 framework is not initialized");
+				break;
+			}
+
+			ret = ipts_send_sensor_clear_mem_window_cmd(ipts);
+			break;
+		}
+		case TOUCH_SENSOR_CLEAR_MEM_WINDOW_RSP:
+		{
+			touch_sensor_set_mode_cmd_data_t sensor_mode_cmd;
+
+			if (rsp_status != 0 &&
+					rsp_status != TOUCH_STATUS_TIMEOUT) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			ret = ipts_allocate_resources(ipts);
+			if (ret) {
+				dev_err(&ipts->cldev->dev, "cannot allocate default resource\n");
+				break;
+			}
+
+			ipts->state = IPTS_STA_RESOURCE_READY;
+
+			cmd_len = sizeof(touch_sensor_set_mode_cmd_data_t);
+			memset(&sensor_mode_cmd, 0, cmd_len);
+			sensor_mode_cmd.sensor_mode = TOUCH_SENSOR_MODE_RAW_DATA;
+			ret = ipts_handle_cmd(ipts,
+				TOUCH_SENSOR_SET_MODE_CMD,
+				&sensor_mode_cmd, cmd_len);
+			break;
+		}
+		case TOUCH_SENSOR_SET_MODE_RSP:
+		{
+			touch_sensor_set_mem_window_cmd_data_t smw_cmd;
+
+			if (rsp_status != 0) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			cmd_len = sizeof(touch_sensor_set_mem_window_cmd_data_t);
+			memset(&smw_cmd, 0, cmd_len);
+			ipts_get_set_mem_window_cmd_data(ipts, &smw_cmd);
+			ret = ipts_handle_cmd(ipts,
+				TOUCH_SENSOR_SET_MEM_WINDOW_CMD,
+				&smw_cmd, cmd_len);
+			break;
+		}
+		case TOUCH_SENSOR_SET_MEM_WINDOW_RSP:
+		{
+			if (rsp_status != 0) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			ret = ipts_hid_init(ipts);
+			if (ret)
+				break;
+
+			ret = ipts_send_sensor_hid_ready_for_data_cmd(ipts);
+			if (ret)
+				break;
+
+			ipts->state = IPTS_STA_RAW_DATA_STARTED;
+
+			break;
+		}
+		case TOUCH_SENSOR_FEEDBACK_READY_RSP:
+		{
+			if (rsp_status != 0 &&
+			  rsp_status != TOUCH_STATUS_COMPAT_CHECK_FAIL) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			break;
+		}
+		case TOUCH_SENSOR_QUIESCE_IO_RSP:
+		{
+			if (rsp_status != 0) {
+				dev_err(&ipts->cldev->dev, "0x%08x failed status = %d\n", cmd, rsp_status);
+				break;
+			}
+
+			break;
+		}
+	}
+
+	return ret;
+}
+
+int ipts_start(ipts_info_t *ipts)
+{
+	int ret;
+
+	ipts->state = IPTS_STA_INIT;
+
+	ret = ipts_handle_cmd(ipts, TOUCH_SENSOR_NOTIFY_DEV_READY_CMD, NULL, 0);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "cannot initiate message workflow\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+void ipts_stop(ipts_info_t *ipts)
+{
+	if (ipts->state == IPTS_STA_RAW_DATA_STARTED)
+		ipts_send_sensor_quiesce_io_cmd(ipts);
+
+	ipts->state = IPTS_STA_STOPPING;
+
+	ipts_hid_fini(ipts);
+
+	ipts_free_resources(ipts);
+
+	intel_ipts_disconnect();
+
+	// Let a delay for IPTS quiesce_io_cmd to be properly handled
+	msleep(250);
+}
diff -ruN a/drivers/misc/ipts/msgs.h b/drivers/misc/ipts/msgs.h
--- a/drivers/misc/ipts/msgs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/msgs.h	2019-11-01 17:01:50.115351776 +0100
@@ -0,0 +1,455 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _IPTS_MSGS_H_
+#define _IPTS_MSGS_H_
+
+#define TOUCH_SENSOR_GET_DEVICE_INFO_CMD		0x00000001
+#define TOUCH_SENSOR_GET_DEVICE_INFO_RSP		0x80000001
+#define TOUCH_SENSOR_SET_MODE_CMD			0x00000002
+#define TOUCH_SENSOR_SET_MODE_RSP			0x80000002
+#define TOUCH_SENSOR_SET_MEM_WINDOW_CMD			0x00000003
+#define TOUCH_SENSOR_SET_MEM_WINDOW_RSP			0x80000003
+#define TOUCH_SENSOR_QUIESCE_IO_CMD			0x00000004
+#define TOUCH_SENSOR_QUIESCE_IO_RSP			0x80000004
+#define TOUCH_SENSOR_HID_READY_FOR_DATA_CMD		0x00000005
+#define TOUCH_SENSOR_HID_READY_FOR_DATA_RSP		0x80000005
+#define TOUCH_SENSOR_FEEDBACK_READY_CMD			0x00000006
+#define TOUCH_SENSOR_FEEDBACK_READY_RSP			0x80000006
+#define TOUCH_SENSOR_CLEAR_MEM_WINDOW_CMD		0x00000007
+#define TOUCH_SENSOR_CLEAR_MEM_WINDOW_RSP		0x80000007
+#define TOUCH_SENSOR_NOTIFY_DEV_READY_CMD		0x00000008
+#define TOUCH_SENSOR_NOTIFY_DEV_READY_RSP		0x80000008
+#define TOUCH_SENSOR_SET_POLICIES_CMD			0x00000009
+#define TOUCH_SENSOR_SET_POLICIES_RSP			0x80000009
+#define TOUCH_SENSOR_GET_POLICIES_CMD			0x0000000A
+#define TOUCH_SENSOR_GET_POLICIES_RSP			0x8000000A
+#define TOUCH_SENSOR_RESET_CMD				0x0000000B
+#define TOUCH_SENSOR_RESET_RSP				0x8000000B
+#define TOUCH_SENSOR_READ_ALL_REGS_CMD			0x0000000C
+#define TOUCH_SENSOR_READ_ALL_REGS_RSP			0x8000000C
+#define TOUCH_SENSOR_CMD_ERROR_RSP			0x8FFFFFFF
+
+typedef union touch_sts_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 int_status				:1;
+		u32 int_type				:4;
+		u32 pwr_state				:2;
+		u32 init_state				:2;
+		u32 busy				:1;
+		u32 reserved				:14;
+		u32 sync_byte				:8;
+	} fields;
+} touch_sts_reg_t;
+
+typedef union touch_frame_char_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 microframe_size			:18;
+		u32 microframes_per_frame		:5;
+		u32 microframe_index			:5;
+		u32 hid_report				:1;
+		u32 reserved				:3;
+	} fields;
+} touch_frame_char_reg_t;
+
+typedef union touch_err_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 invalid_fw				:1;
+		u32 invalid_data			:1;
+		u32 self_test_failed			:1;
+		u32 reserved				:12;
+		u32 fatal_error				:1;
+		u32 vendor_errors			:16;
+	} fields;
+} touch_err_reg_t;
+
+typedef u32  touch_id_reg_t;
+
+typedef union touch_data_sz_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 max_frame_size			:12;
+		u32 max_feedback_size			:8;
+		u32 reserved				:12;
+	} fields;
+} touch_data_sz_reg_t;
+
+typedef union touch_caps_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 reserved0				:1;
+		u32 supported_17Mhz			:1;
+		u32 supported_30Mhz			:1;
+		u32 supported_50Mhz			:1;
+		u32 reserved1				:4;
+		u32 supported_single_io			:1;
+		u32 supported_dual_io			:1;
+		u32 supported_quad_io			:1;
+		u32 bulk_data_max_write			:6;
+		u32 read_delay_timer_value		:3;
+		u32 reserved2				:4;
+		u32 max_touch_points			:8;
+	} fields;
+} touch_caps_reg_t;
+
+typedef union touch_cfg_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 touch_enable			:1;
+		u32 dhpm				:1;
+		u32 bulk_xfer_size			:4;
+		u32 freq_select				:3;
+		u32 reserved				:23;
+	} fields;
+} touch_cfg_reg_t;
+
+typedef union touch_cmd_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 command_code			:8;
+		u32 reserved				:24;
+	} fields;
+} touch_cmd_reg_t;
+
+typedef union touch_pwr_mgmt_ctrl_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 pwr_state_cmd			:3;
+		u32 reserved				:29;
+	} fields;
+} touch_pwr_mgmt_ctrl_reg_t;
+
+typedef union touch_ven_hw_info_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u32 vendor_id				:16;
+		u32 device_id				:16;
+	} fields;
+} touch_ven_hw_info_reg_t;
+
+typedef u32 touch_hw_rev_reg_t;
+
+typedef u32 touch_fw_rev_reg_t;
+
+typedef union touch_compat_rev_reg
+{
+	u32 reg_value;
+	struct
+	{
+		u8 minor;
+		u8 major;
+		u8 intf_rev;
+		u8 kernel_compat_ver;
+	} fields;
+} touch_compat_rev_reg_t;
+
+typedef struct touch_reg_block
+{
+	touch_sts_reg_t sts_reg;
+	touch_frame_char_reg_t frame_char_reg;
+	touch_err_reg_t error_reg;
+	u32 reserved0;
+	touch_id_reg_t id_reg;
+	touch_data_sz_reg_t data_size_reg;
+	touch_caps_reg_t caps_reg;
+	touch_cfg_reg_t cfg_reg;
+	touch_cmd_reg_t cmd_reg;
+	touch_pwr_mgmt_ctrl_reg_t pwm_mgme_ctrl_reg;
+	touch_ven_hw_info_reg_t ven_hw_info_reg;
+	touch_hw_rev_reg_t hw_rev_reg;
+	touch_fw_rev_reg_t fw_rev_reg;
+	touch_compat_rev_reg_t compat_rev_reg;
+	u32 reserved1;
+	u32 reserved2;
+} touch_reg_block_t;
+
+typedef enum output_buffer_payload_type {
+	OUTPUT_BUFFER_PAYLOAD_ERROR = 0,
+	OUTPUT_BUFFER_PAYLOAD_HID_INPUT_REPORT,
+	OUTPUT_BUFFER_PAYLOAD_HID_FEATURE_REPORT,
+	OUTPUT_BUFFER_PAYLOAD_KERNEL_LOAD,
+	OUTPUT_BUFFER_PAYLOAD_FEEDBACK_BUFFER
+} output_buffer_payload_type_t;
+
+typedef enum touch_status
+{
+	TOUCH_STATUS_SUCCESS = 0,
+	TOUCH_STATUS_INVALID_PARAMS,
+	TOUCH_STATUS_ACCESS_DENIED,
+	TOUCH_STATUS_CMD_SIZE_ERROR,
+	TOUCH_STATUS_NOT_READY,
+	TOUCH_STATUS_REQUEST_OUTSTANDING,
+	TOUCH_STATUS_NO_SENSOR_FOUND,
+	TOUCH_STATUS_OUT_OF_MEMORY,
+	TOUCH_STATUS_INTERNAL_ERROR,
+	TOUCH_STATUS_SENSOR_DISABLED,
+	TOUCH_STATUS_COMPAT_CHECK_FAIL,
+	TOUCH_STATUS_SENSOR_EXPECTED_RESET,
+	TOUCH_STATUS_SENSOR_UNEXPECTED_RESET,
+	TOUCH_STATUS_RESET_FAILED,
+	TOUCH_STATUS_TIMEOUT,
+	TOUCH_STATUS_TEST_MODE_FAIL,
+	TOUCH_STATUS_SENSOR_FAIL_FATAL,
+	TOUCH_STATUS_SENSOR_FAIL_NONFATAL,
+	TOUCH_STATUS_INVALID_DEVICE_CAPS,
+	TOUCH_STATUS_QUIESCE_IO_IN_PROGRESS,
+	TOUCH_STATUS_MAX
+} touch_status_t;
+
+typedef struct touch_hid_private_data
+{
+	u32 transaction_id;
+	u8 reserved[28];
+} touch_hid_private_data_t;
+
+typedef struct kernel_output_buffer_header {
+	u16 length;
+	u8 payload_type;
+	u8 reserved1;
+	touch_hid_private_data_t hid_private_data;
+	u8 reserved2[28];
+	u8 data[0];
+} kernel_output_buffer_header_t;
+
+typedef struct kernel_output_payload_error {
+	u16 severity;
+	u16 source;
+	u8 code[4];
+	char string[128];
+} kernel_output_payload_error_t;
+
+typedef struct touch_feedback_hdr
+{
+	u32 feedback_cmd_type;
+	u32 payload_size_bytes;
+	u32 buffer_id;
+	u32 protocol_ver;
+	u32 feedback_data_type;
+	u32 spi_offest;
+	u8 reserved[40];
+} touch_feedback_hdr_t;
+
+typedef struct touch_sensor_set_mode_cmd_data
+{
+	touch_sensor_mode_t sensor_mode;
+	u32 reserved[3];
+} touch_sensor_set_mode_cmd_data_t;
+
+typedef struct touch_sensor_set_mem_window_cmd_data
+{
+	u32 touch_data_buffer_addr_lower[TOUCH_SENSOR_MAX_DATA_BUFFERS];
+	u32 touch_data_buffer_addr_upper[TOUCH_SENSOR_MAX_DATA_BUFFERS];
+	u32 tail_offset_addr_lower;
+	u32 tail_offset_addr_upper;
+	u32 doorbell_cookie_addr_lower;
+	u32 doorbell_cookie_addr_upper;
+	u32 feedback_buffer_addr_lower[TOUCH_SENSOR_MAX_DATA_BUFFERS];
+	u32 feedback_buffer_addr_upper[TOUCH_SENSOR_MAX_DATA_BUFFERS];
+	u32 hid2me_buffer_addr_lower;
+	u32 hid2me_buffer_addr_upper;
+	u32 hid2me_buffer_size;
+	u8 reserved1;
+	u8 work_queue_item_size;
+	u16 work_queue_size;
+	u32 reserved[8];
+} touch_sensor_set_mem_window_cmd_data_t;
+
+typedef struct touch_sensor_quiesce_io_cmd_data
+{
+	u32 quiesce_flags;
+	u32 reserved[2];
+} touch_sensor_quiesce_io_cmd_data_t;
+
+typedef struct touch_sensor_feedback_ready_cmd_data
+{
+	u8 feedback_index;
+	u8 reserved1[3];
+	u32 transaction_id;
+	u32 reserved2[2];
+} touch_sensor_feedback_ready_cmd_data_t;
+
+typedef enum touch_freq_override
+{
+	TOUCH_FREQ_OVERRIDE_NONE,
+	TOUCH_FREQ_OVERRIDE_10MHZ,
+	TOUCH_FREQ_OVERRIDE_17MHZ,
+	TOUCH_FREQ_OVERRIDE_30MHZ,
+	TOUCH_FREQ_OVERRIDE_50MHZ,
+	TOUCH_FREQ_OVERRIDE_MAX
+} touch_freq_override_t;
+
+typedef enum touch_spi_io_mode_override
+{
+	TOUCH_SPI_IO_MODE_OVERRIDE_NONE,
+	TOUCH_SPI_IO_MODE_OVERRIDE_SINGLE,
+	TOUCH_SPI_IO_MODE_OVERRIDE_DUAL,
+	TOUCH_SPI_IO_MODE_OVERRIDE_QUAD,
+	TOUCH_SPI_IO_MODE_OVERRIDE_MAX
+} touch_spi_io_mode_override_t;
+
+typedef struct touch_policy_data
+{
+	u32 reserved0;
+	u32 doze_timer					:16;
+	touch_freq_override_t freq_override		:3;
+	touch_spi_io_mode_override_t spi_io_override	:3;
+	u32 reserved1					:10;
+	u32 reserved2;
+	u32 debug_override;
+} touch_policy_data_t;
+
+typedef struct touch_sensor_set_policies_cmd_data
+{
+	touch_policy_data_t policy_data;
+} touch_sensor_set_policies_cmd_data_t;
+
+typedef enum touch_sensor_reset_type
+{
+	TOUCH_SENSOR_RESET_TYPE_HARD,
+	TOUCH_SENSOR_RESET_TYPE_SOFT,
+	TOUCH_SENSOR_RESET_TYPE_MAX
+} touch_sensor_reset_type_t;
+
+typedef struct touch_sensor_reset_cmd_data
+{
+	touch_sensor_reset_type_t reset_type;
+	u32 reserved;
+} touch_sensor_reset_cmd_data_t;
+
+typedef struct touch_sensor_msg_h2m
+{
+	u32  command_code;
+	union
+	{
+		touch_sensor_set_mode_cmd_data_t set_mode_cmd_data;
+		touch_sensor_set_mem_window_cmd_data_t set_window_cmd_data;
+		touch_sensor_quiesce_io_cmd_data_t quiesce_io_cmd_data;
+		touch_sensor_feedback_ready_cmd_data_t feedback_ready_cmd_data;
+		touch_sensor_set_policies_cmd_data_t set_policies_cmd_data;
+		touch_sensor_reset_cmd_data_t reset_cmd_data;
+	} h2m_data;
+} touch_sensor_msg_h2m_t;
+
+typedef struct touch_sensor_set_mode_rsp_data
+{
+	u32 reserved[3];
+} touch_sensor_set_mode_rsp_data_t;
+
+typedef struct touch_sensor_set_mem_window_rsp_data
+{
+	u32 reserved[3];
+} touch_sensor_set_mem_window_rsp_data_t;
+
+typedef struct touch_sensor_quiesce_io_rsp_data
+{
+	u32 reserved[3];
+} touch_sensor_quiesce_io_rsp_data_t;
+
+typedef struct touch_sensor_hid_ready_for_data_rsp_data
+{
+	u32 data_size;
+	u8 touch_data_buffer_index;
+	u8 reset_reason;
+	u8 reserved1[2];
+	u32 reserved2[5];
+} touch_sensor_hid_ready_for_data_rsp_data_t;
+
+typedef struct touch_sensor_feedback_ready_rsp_data
+{
+	u8 feedback_index;
+	u8 reserved1[3];
+	u32 reserved2[6];
+} touch_sensor_feedback_ready_rsp_data_t;
+
+typedef struct touch_sensor_clear_mem_window_rsp_data
+{
+	u32 reserved[3];
+} touch_sensor_clear_mem_window_rsp_data_t;
+
+typedef struct touch_sensor_notify_dev_ready_rsp_data
+{
+	touch_err_reg_t err_reg;
+	u32 reserved[2];
+} touch_sensor_notify_dev_ready_rsp_data_t;
+
+typedef struct touch_sensor_set_policies_rsp_data
+{
+	u32 reserved[3];
+} touch_sensor_set_policies_rsp_data_t;
+
+typedef struct touch_sensor_get_policies_rsp_data
+{
+	touch_policy_data_t policy_data;
+} touch_sensor_get_policies_rsp_data_t;
+
+typedef struct touch_sensor_reset_rsp_data
+{
+	u32 reserved[3];
+} touch_sensor_reset_rsp_data_t;
+
+typedef struct touch_sensor_read_all_regs_rsp_data
+{
+	touch_reg_block_t sensor_regs;
+	u32 reserved[4];
+} touch_sensor_read_all_regs_rsp_data_t;
+
+typedef struct touch_sensor_msg_m2h
+{
+	u32 command_code;
+	touch_status_t status;
+	union
+	{
+		touch_sensor_get_device_info_rsp_data_t	device_info_rsp_data;
+		touch_sensor_set_mode_rsp_data_t set_mode_rsp_data;
+		touch_sensor_set_mem_window_rsp_data_t set_mem_window_rsp_data;
+		touch_sensor_quiesce_io_rsp_data_t quiesce_io_rsp_data;
+		touch_sensor_hid_ready_for_data_rsp_data_t hid_ready_for_data_rsp_data;
+		touch_sensor_feedback_ready_rsp_data_t feedback_ready_rsp_data;
+		touch_sensor_clear_mem_window_rsp_data_t clear_mem_window_rsp_data;
+		touch_sensor_notify_dev_ready_rsp_data_t notify_dev_ready_rsp_data;
+		touch_sensor_set_policies_rsp_data_t set_policies_rsp_data;
+		touch_sensor_get_policies_rsp_data_t get_policies_rsp_data;
+		touch_sensor_reset_rsp_data_t reset_rsp_data;
+		touch_sensor_read_all_regs_rsp_data_t read_all_regs_rsp_data;
+	} m2h_data;
+} touch_sensor_msg_m2h_t;
+
+int ipts_hid_send_hid2me_feedback(ipts_info_t *ipts, u32 fb_data_type, __u8 *buf, size_t count);
+int ipts_handle_resp(ipts_info_t *ipts, touch_sensor_msg_m2h_t *m2h_msg, u32 msg_len);
+int ipts_start(ipts_info_t *ipts);
+void ipts_stop(ipts_info_t *ipts);
+
+#endif // _IPTS_MSGS_H_
diff -ruN a/drivers/misc/ipts/resources.c b/drivers/misc/ipts/resources.c
--- a/drivers/misc/ipts/resources.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/resources.c	2019-11-01 16:57:47.340705625 +0100
@@ -0,0 +1,841 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <linux/intel-ipts.h>
+
+#include "resources.h"
+
+static ipts_mapbuffer_t *ipts_map_buffer(ipts_info_t *ipts, u32 size, u32 flags)
+{
+	ipts_mapbuffer_t *buf;
+	int ret;
+
+	buf = devm_kzalloc(&ipts->cldev->dev, sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return NULL;
+
+	buf->size = size;
+	buf->flags = flags;
+
+	ret = intel_ipts_map_buffer(buf);
+	if (ret) {
+		devm_kfree(&ipts->cldev->dev, buf);
+		return NULL;
+	}
+
+	return buf;
+}
+
+static void ipts_unmap_buffer(ipts_info_t *ipts, ipts_mapbuffer_t *buf)
+{
+	if (!buf)
+		return;
+
+	intel_ipts_unmap_buffer(buf->buf_handle);
+
+	devm_kfree(&ipts->cldev->dev, buf);
+}
+
+static int bin_read_fw(ipts_info_t *ipts, u8* data, int size)
+{
+	const struct firmware *fw = NULL;
+	char fw_path[256];
+	int ret = 0;
+
+	snprintf(fw_path, 256, "intel/ipts/SurfaceTouchServicingSFTConfig%s.bin", ipts->hardware_id);
+	ret = request_firmware(&fw, fw_path, &ipts->cldev->dev);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "cannot read fw %s\n", fw_path);
+		return ret;
+	}
+
+	if (fw->size > size) {
+		dev_err(&ipts->cldev->dev, "too small buffer to contain fw data\n");
+		ret = -EINVAL;
+		goto rel_return;
+	}
+
+	memcpy(data, fw->data, fw->size);
+
+rel_return:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static int bin_read_allocation_list(ipts_info_t *ipts,
+					bin_parse_info_t *parse_info,
+					bin_alloc_info_t *alloc_info)
+{
+	ipts_bin_alloc_list_t *alloc_list;
+	int alloc_idx, buf_idx, num_of_buffers, parallel_idx, parsed, size;
+
+	parsed = parse_info->parsed;
+	size = parse_info->size;
+
+	alloc_list = (ipts_bin_alloc_list_t *)&parse_info->data[parsed];
+
+	if (sizeof(alloc_list->num) > size - parsed)
+		return -EINVAL;
+
+	parsed += sizeof(alloc_list->num);
+
+	if (sizeof(alloc_list->alloc[0]) * alloc_list->num > size - parsed)
+		return -EINVAL;
+
+	num_of_buffers = TOUCH_SENSOR_MAX_DATA_BUFFERS * alloc_list->num + TOUCH_SENSOR_MAX_DATA_BUFFERS;
+
+	alloc_info->buffs = vmalloc(sizeof(bin_buffer_t) * num_of_buffers);
+	if (alloc_info->buffs == NULL)
+		return -ENOMEM;
+
+	memset(alloc_info->buffs, 0, sizeof(bin_buffer_t) * num_of_buffers);
+	for (alloc_idx = 0; alloc_idx < alloc_list->num; alloc_idx++) {
+		for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+			buf_idx = alloc_idx + (parallel_idx * alloc_list->num);
+			alloc_info->buffs[buf_idx].handle =
+					alloc_list->alloc[alloc_idx].handle;
+
+		}
+
+		parsed += sizeof(alloc_list->alloc[0]);
+	}
+
+	parse_info->parsed = parsed;
+	alloc_info->num_of_allocations = alloc_list->num;
+	alloc_info->num_of_buffers = num_of_buffers;
+
+	dev_dbg(&ipts->cldev->dev, "number of allocations = %d, buffers = %d\n",
+						alloc_info->num_of_allocations,
+						alloc_info->num_of_buffers);
+
+	return 0;
+}
+
+static int bin_read_cmd_buffer(ipts_info_t *ipts,
+					bin_parse_info_t *parse_info,
+					bin_alloc_info_t *alloc_info,
+					bin_workload_t *wl)
+{
+	ipts_bin_cmdbuf_t *cmd;
+	ipts_mapbuffer_t *buf;
+	int cmdbuf_idx, parallel_idx, parsed, size;
+
+	size = parse_info->size;
+	parsed = parse_info->parsed;
+
+	cmd = (ipts_bin_cmdbuf_t *)&parse_info->data[parsed];
+
+	if (sizeof(cmd->size) > size - parsed)
+		return -EINVAL;
+
+	parsed += sizeof(cmd->size);
+	if (cmd->size > size - parsed)
+		return -EINVAL;
+
+	dev_dbg(&ipts->cldev->dev, "cmd buf size = %d\n", cmd->size);
+
+	cmdbuf_idx = TOUCH_SENSOR_MAX_DATA_BUFFERS * alloc_info->num_of_allocations;
+	for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+		buf = ipts_map_buffer(ipts, cmd->size, 0);
+		if (buf == NULL)
+			return -ENOMEM;
+
+		dev_dbg(&ipts->cldev->dev, "cmd_idx[%d] = %d, g:0x%p, c:0x%p\n", parallel_idx,
+					cmdbuf_idx, buf->gfx_addr, buf->cpu_addr);
+
+		memcpy((void *)buf->cpu_addr, &(cmd->data[0]), cmd->size);
+		alloc_info->buffs[cmdbuf_idx].buf = buf;
+		wl[parallel_idx].cmdbuf_index = cmdbuf_idx;
+
+		cmdbuf_idx++;
+	}
+
+	parsed += cmd->size;
+	parse_info->parsed = parsed;
+
+	return 0;
+}
+
+static int bin_read_res_list(ipts_info_t *ipts,
+					bin_parse_info_t *parse_info,
+					bin_alloc_info_t *alloc_info,
+					bin_workload_t *wl)
+{
+	ipts_bin_res_list_t *res_list;
+	ipts_bin_res_t *res;
+	ipts_mapbuffer_t *buf;
+	int buf_idx, i, parallel_idx, parsed, size, output_idx = -1;
+	u8 *bin_data;
+	u32 buf_size, io_buf_type;
+	
+	parsed = parse_info->parsed;
+	size = parse_info->size;
+	bin_data = parse_info->data;
+
+	res_list = (ipts_bin_res_list_t *)&parse_info->data[parsed];
+	if (sizeof(res_list->num) > (size - parsed))
+		return -EINVAL;
+	parsed += sizeof(res_list->num);
+
+	dev_dbg(&ipts->cldev->dev, "number of resources %u\n", res_list->num);
+	for (i = 0; i < res_list->num; i++) {
+		io_buf_type = 0;
+
+		res = (ipts_bin_res_t *)(&(bin_data[parsed]));
+		if (sizeof(res[0]) > (size - parsed)) {
+			return -EINVAL;
+		}
+
+		dev_dbg(&ipts->cldev->dev, "Resource(%d):handle 0x%08x type %u init %u"
+				" size %u aligned_size %u data 0x%08x\n",
+				i, res->handle, res->type, res->initialize,
+				res->size, res->aligned_size, res->data[0]);
+                parsed += sizeof(res[0]);
+
+		if (res->initialize) {
+			if (res->size > (size - parsed)) {
+				return -EINVAL;
+			}
+			parsed += res->size;
+		}
+
+		if (res->aligned_size) {
+			ipts_bin_io_header_t *io_hdr;
+			int alloc;
+			for (alloc = 0; alloc < alloc_info->num_of_allocations; alloc++) {
+				if (alloc_info->buffs[alloc].handle == res->handle)
+					break;
+			}
+
+			if (alloc == alloc_info->num_of_allocations)
+				dev_dbg(&ipts->cldev->dev,
+				       "Couldnt match the handle 0x%x in res list\n", alloc);
+
+			if (alloc_info->buffs[alloc].buf != NULL) {
+				dev_dbg(&ipts->cldev->dev,
+				    "Duplicate entry for resource index %d\n",
+				     alloc);
+				continue;
+			}
+
+			io_hdr = vmalloc(sizeof(ipts_bin_io_header_t));
+			if (res->size > sizeof(ipts_bin_io_header_t)) {
+				io_hdr = (ipts_bin_io_header_t *)(&res->data[0]);
+				if (strncmp(io_hdr->str, "INTELTOUCH", 10) == 0)
+					io_buf_type = (1 << io_hdr->type);
+				if (io_buf_type == 2)
+					output_idx++;
+			}
+
+			for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+				buf_idx = alloc + (parallel_idx * alloc_info->num_of_allocations);
+				buf_size = res->aligned_size;
+				if (io_buf_type == 1)
+					wl[parallel_idx].iobuf_input = buf_idx;
+				else if (io_buf_type == 2)
+					wl[parallel_idx].iobuf_output[output_idx] = buf_idx;
+				else if (parallel_idx != 0)
+						continue;
+
+				buf = ipts_map_buffer(ipts, buf_size, 1);
+				if (!buf)
+					return -ENOMEM;
+
+				alloc_info->buffs[buf_idx].buf = buf;
+
+				if (io_buf_type == 4) {
+					bin_read_fw(ipts, buf->cpu_addr, buf_size);
+					continue;
+				}
+
+				if (res->initialize)
+					memcpy((void *)buf->cpu_addr, &(res->data[0]), res->size);
+				else
+					memset((void *)buf->cpu_addr, 0x0, buf_size);
+			}
+		}
+	}
+
+        alloc_info->num_of_outputs = output_idx + 1;
+	parse_info->parsed = parsed;
+
+	return 0;
+}
+
+static int bin_read_patch_list(ipts_info_t *ipts,
+					bin_parse_info_t *parse_info,
+					bin_alloc_info_t *alloc_info,
+					bin_workload_t *wl)
+{
+	ipts_bin_patch_list_t *patch_list;
+	ipts_mapbuffer_t *cmd = NULL;
+	int buf_idx, cmd_idx, i, parallel_idx, parsed, size;
+	u8 *batch;
+	unsigned int gtt_offset;
+
+	parsed = parse_info->parsed;
+	size = parse_info->size;
+	patch_list = (ipts_bin_patch_list_t *)&parse_info->data[parsed];
+
+	if (sizeof(patch_list->num) > (size - parsed)) {
+		return -EFAULT;
+	}
+	parsed += sizeof(patch_list->num);
+
+	for (i = 0; i < patch_list->num; i++) {
+		if (sizeof(patch_list->patch[0]) > (size - parsed)) {
+			return -EFAULT;
+		}
+
+		for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+			cmd_idx = wl[parallel_idx].cmdbuf_index;
+			buf_idx = patch_list->patch[i].index + parallel_idx *
+						alloc_info->num_of_allocations;
+
+			if (alloc_info->buffs[buf_idx].buf == NULL)
+				buf_idx = patch_list->patch[i].index;
+
+			cmd = alloc_info->buffs[cmd_idx].buf;
+			batch = (char *)(u64)cmd->cpu_addr;
+
+			gtt_offset = 0;
+			if(alloc_info->buffs[buf_idx].buf != NULL)
+				gtt_offset = (u32)(u64)
+					alloc_info->buffs[buf_idx].buf->gfx_addr;
+			gtt_offset += patch_list->patch[i].alloc_offset;
+
+			batch += patch_list->patch[i].patch_offset;
+			*(u32*)batch = gtt_offset;
+		}
+
+		parsed += sizeof(patch_list->patch[0]);
+	}
+
+	parse_info->parsed = parsed;
+
+	return 0;
+}
+
+static int bin_read_guc_wq_item(ipts_info_t *ipts,
+					bin_parse_info_t *parse_info,
+					bin_guc_wq_item_t **guc_wq_item)
+{
+	ipts_bin_guc_wq_info_t *bin_guc_wq;
+	bin_guc_wq_item_t *item;
+	int hdr_size, i, parsed, size;
+	
+	parsed = parse_info->parsed;
+	size = parse_info->size;
+	bin_guc_wq = (ipts_bin_guc_wq_info_t *)&parse_info->data[parsed];
+
+	dev_dbg(&ipts->cldev->dev, "wi size = %d, bt offset = %d\n", bin_guc_wq->size, bin_guc_wq->batch_offset);
+	for (i = 0; i < bin_guc_wq->size / sizeof(u32); i++) {
+		dev_dbg(&ipts->cldev->dev, "wi[%d] = 0x%08x\n", i, *((u32*)bin_guc_wq->data + i));
+	}
+	hdr_size = sizeof(bin_guc_wq->size) + sizeof(bin_guc_wq->batch_offset);
+
+	if (hdr_size > (size - parsed)) {
+		return -EINVAL;
+	}
+	parsed += hdr_size;
+
+	item = vmalloc(sizeof(bin_guc_wq_item_t) + bin_guc_wq->size);
+	if (item == NULL)
+		return -ENOMEM;
+
+	item->size = bin_guc_wq->size;
+	item->batch_offset = bin_guc_wq->batch_offset;
+	memcpy(item->data, bin_guc_wq->data, bin_guc_wq->size);
+
+	*guc_wq_item = item;
+
+	parsed += bin_guc_wq->size;
+	parse_info->parsed = parsed;
+
+	return 0;
+}
+
+static int bin_setup_guc_workqueue(ipts_info_t *ipts,
+					bin_kernel_info_t *kernel)
+{
+	bin_alloc_info_t *alloc_info;
+	bin_buffer_t *bin_buf;
+	bin_workload_t *wl;
+	int batch_offset, cmd_idx, i, iter_size, parallel_idx, wi_size, wq_size;
+	u8 *wq_start, *wq_addr, *wi_data;
+	
+	wq_addr = (u8*)ipts->resources.wq_info.wq_addr;
+	wq_size = ipts->resources.wq_info.wq_size;
+
+	iter_size = ipts->resources.wq_item_size * TOUCH_SENSOR_MAX_DATA_BUFFERS;
+	if (wq_size % iter_size) {
+		dev_err(&ipts->cldev->dev, "wq item cannot fit into wq\n");
+		return -EINVAL;
+	}
+
+	wq_start = wq_addr;
+	for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS;
+							parallel_idx++) {
+			wl = kernel->wl;
+			alloc_info = kernel->alloc_info;
+
+			batch_offset = kernel->guc_wq_item->batch_offset;
+			wi_size = kernel->guc_wq_item->size;
+			wi_data = &kernel->guc_wq_item->data[0];
+			
+			cmd_idx = wl[parallel_idx].cmdbuf_index;
+			bin_buf = &alloc_info->buffs[cmd_idx];
+
+			*(u32*)(wi_data + batch_offset) =
+				(u32)(unsigned long)(bin_buf->buf->gfx_addr);
+
+			memcpy(wq_addr, wi_data, wi_size);
+
+			wq_addr += wi_size;
+	}
+
+	for (i = 0; i < (wq_size / iter_size) - 1; i++) {
+		memcpy(wq_addr, wq_start, iter_size);
+		wq_addr += iter_size;
+	}
+
+	return 0;
+}
+
+static int bin_read_bufid_patch(ipts_info_t *ipts,
+					bin_parse_info_t *parse_info,
+					ipts_bin_bufid_patch_t *bufid_patch)
+{
+	ipts_bin_bufid_patch_t *patch;
+	int size, parsed;
+
+	parsed = parse_info->parsed;
+	size = parse_info->size;
+	patch = (ipts_bin_bufid_patch_t *)&parse_info->data[parsed];
+
+	if (sizeof(ipts_bin_bufid_patch_t) > (size - parsed)) {
+		dev_err(&ipts->cldev->dev, "invalid bufid info\n");
+		return -EINVAL;
+	}
+	parsed += sizeof(ipts_bin_bufid_patch_t);
+
+	memcpy(bufid_patch, patch, sizeof(ipts_bin_bufid_patch_t));
+
+	parse_info->parsed = parsed;
+
+	return 0;
+}
+
+static int bin_setup_bufid_buffer(ipts_info_t *ipts, bin_kernel_info_t *kernel)
+{
+	bin_alloc_info_t *alloc_info;
+	bin_workload_t *wl;
+	ipts_mapbuffer_t *buf, *cmd_buf;
+	int cmd_idx, parallel_idx;
+	u8 *batch;
+	u32 mem_offset, imm_offset;
+
+	buf = ipts_map_buffer(ipts, PAGE_SIZE, 0);
+	if (!buf) {
+		return -ENOMEM;
+	}
+
+	mem_offset = kernel->bufid_patch.mem_offset;
+	imm_offset = kernel->bufid_patch.imm_offset;
+	wl = kernel->wl;
+	alloc_info = kernel->alloc_info;
+
+        *((u32*)buf->cpu_addr) = -1;
+	ipts->resources.last_buffer_completed = -1;
+	ipts->resources.last_buffer_submitted = (int*)buf->cpu_addr;
+
+	for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+		cmd_idx = wl[parallel_idx].cmdbuf_index;
+		cmd_buf = alloc_info->buffs[cmd_idx].buf;
+		batch = (u8*)(u64)cmd_buf->cpu_addr;
+
+		*((u32*)(batch + mem_offset)) = (u32)(u64)(buf->gfx_addr);
+                *((u32*)(batch + imm_offset)) = parallel_idx;
+	}
+
+	kernel->bufid_buf = buf;
+
+	return 0;
+}
+
+static void unmap_buffers(ipts_info_t *ipts, bin_alloc_info_t *alloc_info)
+{
+	bin_buffer_t *buffs;
+	int i, num_of_buffers;
+
+	num_of_buffers = alloc_info->num_of_buffers;
+	buffs = &alloc_info->buffs[0];
+
+	for (i = 0; i < num_of_buffers; i++) {
+		if (buffs[i].buf != NULL)
+			ipts_unmap_buffer(ipts, buffs[i].buf);
+	}
+}
+
+static int load_kernel(ipts_info_t *ipts, bin_parse_info_t *parse_info,
+						bin_kernel_info_t *kernel)
+{
+	ipts_bin_header_t *hdr;
+	bin_workload_t *wl;
+	bin_alloc_info_t *alloc_info;
+	bin_guc_wq_item_t *guc_wq_item = NULL;
+	ipts_bin_bufid_patch_t bufid_patch;
+	int ret;
+
+	hdr = (ipts_bin_header_t *)parse_info->data;
+	if (strncmp(hdr->str, "IOCL", 4) != 0) {
+		dev_err(&ipts->cldev->dev, "binary header is not correct version = %d, "
+				"string = %c%c%c%c\n", hdr->version,
+				hdr->str[0], hdr->str[1],
+				hdr->str[2], hdr->str[3] );
+		return -EINVAL;
+	}
+
+	parse_info->parsed = sizeof(ipts_bin_header_t);
+	wl = vmalloc(sizeof(bin_workload_t) * TOUCH_SENSOR_MAX_DATA_BUFFERS);
+	if (wl == NULL)
+		return -ENOMEM;
+	memset(wl, 0, sizeof(bin_workload_t) * TOUCH_SENSOR_MAX_DATA_BUFFERS);
+
+	alloc_info = vmalloc(sizeof(bin_alloc_info_t));
+	if (alloc_info == NULL) {
+		vfree(wl);
+		return -ENOMEM;
+	}
+	memset(alloc_info, 0, sizeof(bin_alloc_info_t));
+
+        dev_dbg(&ipts->cldev->dev, "kernel setup(size : %d)\n", parse_info->size);
+
+	ret = bin_read_allocation_list(ipts, parse_info, alloc_info);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error read_allocation_list\n");
+		goto setup_error;
+	}
+
+	ret = bin_read_cmd_buffer(ipts, parse_info, alloc_info, wl);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error read_cmd_buffer\n");
+		goto setup_error;
+	}
+
+	ret = bin_read_res_list(ipts, parse_info, alloc_info, wl);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error read_res_list\n");
+		goto setup_error;
+	}
+
+	ret = bin_read_patch_list(ipts, parse_info, alloc_info, wl);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error read_patch_list\n");
+		goto setup_error;
+	}
+
+	ret = bin_read_guc_wq_item(ipts, parse_info, &guc_wq_item);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error read_guc_workqueue\n");
+		goto setup_error;
+	}
+
+	memset(&bufid_patch, 0, sizeof(bufid_patch));
+	ret = bin_read_bufid_patch(ipts, parse_info, &bufid_patch);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error read_bufid_patch\n");
+		goto setup_error;
+	}
+
+	kernel->wl = wl;
+	kernel->alloc_info = alloc_info;
+	kernel->guc_wq_item = guc_wq_item;
+	memcpy(&kernel->bufid_patch, &bufid_patch, sizeof(bufid_patch));
+
+        return 0;
+
+setup_error:
+	vfree(guc_wq_item);
+
+	unmap_buffers(ipts, alloc_info);
+
+	vfree(alloc_info->buffs);
+	vfree(alloc_info);
+	vfree(wl);
+
+	return ret;
+}
+
+void ipts_set_input_buffer(ipts_info_t *ipts, int parallel_idx,
+						u8* cpu_addr, u64 dma_addr)
+{
+	ipts_buffer_info_t *touch_buf;
+
+	touch_buf = ipts->resources.touch_data_buffer_raw;
+	touch_buf[parallel_idx].dma_addr = dma_addr;
+	touch_buf[parallel_idx].addr = cpu_addr;
+}
+
+void ipts_set_output_buffer(ipts_info_t *ipts, int parallel_idx, int output_idx,
+						u8* cpu_addr, u64 dma_addr)
+{
+	ipts_buffer_info_t *output_buf;
+
+	output_buf = &ipts->resources.raw_data_mode_output_buffer[parallel_idx][output_idx];
+
+	output_buf->dma_addr = dma_addr;
+	output_buf->addr = cpu_addr;
+}
+
+static void bin_setup_input_output(ipts_info_t *ipts, bin_kernel_info_t *kernel)
+{
+	bin_workload_t *wl;
+	ipts_mapbuffer_t *buf;
+	bin_alloc_info_t *alloc_info;
+	int buf_idx, i, parallel_idx;
+
+	wl = kernel->wl;
+	alloc_info = kernel->alloc_info;
+	ipts->resources.num_of_outputs = alloc_info->num_of_outputs;
+
+	for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+		buf_idx = wl[parallel_idx].iobuf_input;
+		buf = alloc_info->buffs[buf_idx].buf;
+
+		dev_dbg(&ipts->cldev->dev, "in_buf[%d](%d) c:%p, p:%p, g:%p\n",
+					parallel_idx, buf_idx, (void*)buf->cpu_addr,
+					(void*)buf->phy_addr, (void*)buf->gfx_addr);
+
+		ipts_set_input_buffer(ipts, parallel_idx, buf->cpu_addr,
+								buf->phy_addr);
+
+		for (i = 0; i < alloc_info->num_of_outputs; i++) {
+			buf_idx = wl[parallel_idx].iobuf_output[i];
+			buf = alloc_info->buffs[buf_idx].buf;
+
+			dev_dbg(&ipts->cldev->dev, "out_buf[%d][%d] c:%p, p:%p, g:%p\n",
+					parallel_idx, i, (void*)buf->cpu_addr,
+					(void*)buf->phy_addr, (void*)buf->gfx_addr);
+
+			ipts_set_output_buffer(ipts, parallel_idx, i,
+					buf->cpu_addr, buf->phy_addr);
+		}
+	}
+}
+
+static void unload_kernel(ipts_info_t *ipts, bin_kernel_info_t *kernel)
+{
+	bin_alloc_info_t *alloc_info = kernel->alloc_info;
+	bin_guc_wq_item_t *guc_wq_item = kernel->guc_wq_item;
+
+	if (guc_wq_item) {
+		vfree(guc_wq_item);
+	}
+
+	if (alloc_info) {
+		unmap_buffers(ipts, alloc_info);
+
+		vfree(alloc_info->buffs);
+		vfree(alloc_info);
+	}
+}
+
+static int setup_kernel(ipts_info_t *ipts)
+{
+	bin_kernel_info_t *kernel = NULL;
+	const struct firmware *fw = NULL;
+	bin_workload_t *wl;
+	bin_parse_info_t parse_info;
+	int ret = 0;
+	char fw_path[256];
+
+	kernel = vmalloc(sizeof(*kernel));
+	if (kernel == NULL)
+		return -ENOMEM;
+
+	memset(kernel, 0, sizeof(*kernel));
+
+	if (!strcmp(ipts->hardware_id, "MSHW0076") || !strcmp(ipts->hardware_id, "MSHW0078") || !strcmp(ipts->hardware_id, "MSHW0103"))
+		snprintf(fw_path, 256, "intel/ipts/SurfaceTouchServicingKernelSKL%s.bin", ipts->hardware_id);
+	else
+		snprintf(fw_path, 256, "intel/ipts/SurfaceTouchServicingKernel%s.bin", ipts->hardware_id);
+	ret = request_firmware(&fw, (const char *)fw_path, &ipts->cldev->dev);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "cannot read fw %s\n", fw_path);
+		goto error_exit;
+	}
+
+	parse_info.data = (u8*)fw->data;
+	parse_info.size = fw->size;
+	parse_info.parsed = 0;
+
+	ret = load_kernel(ipts, &parse_info, kernel);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "do_setup_kernel error : %d\n", ret);
+		release_firmware(fw);
+		goto error_exit;
+	}
+
+	release_firmware(fw);
+
+	ipts->resources.wq_item_size = kernel->guc_wq_item->size;
+	
+	ret = bin_setup_guc_workqueue(ipts, kernel);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error setup_guc_workqueue\n");
+		goto error_exit;
+	}
+
+	ret = bin_setup_bufid_buffer(ipts, kernel);
+	if (ret) {
+        	dev_err(&ipts->cldev->dev, "error setup_lastbubmit_buffer\n");
+		goto error_exit;
+	}
+
+	bin_setup_input_output(ipts, kernel);
+
+	wl = kernel->wl;
+	vfree(wl);
+	
+	ipts->resources.kernel_handle = (u64)kernel;
+
+	return 0;
+
+error_exit:
+
+	wl = kernel->wl;
+	vfree(wl);
+	unload_kernel(ipts, kernel);
+
+	vfree(kernel);
+
+	return ret;
+}
+
+static void release_kernel(ipts_info_t *ipts)
+{
+	bin_kernel_info_t *kernel;
+
+	kernel = (bin_kernel_info_t *)ipts->resources.kernel_handle;
+
+	unload_kernel(ipts, kernel);
+
+	ipts_unmap_buffer(ipts, kernel->bufid_buf);
+
+	vfree(kernel);
+
+	ipts->resources.kernel_handle = 0;
+}
+
+static int ipts_allocate_common_resource(ipts_info_t *ipts)
+{
+	char *addr, *me2hid_addr;
+	dma_addr_t dma_addr;
+	int parallel_idx;
+
+	addr = dmam_alloc_coherent(&ipts->cldev->dev,
+			ipts->device_info.feedback_size,
+			&dma_addr,
+			GFP_ATOMIC|__GFP_ZERO);
+	if (addr == NULL)
+		return -ENOMEM;
+
+	me2hid_addr = devm_kzalloc(&ipts->cldev->dev, ipts->device_info.feedback_size, GFP_KERNEL);
+	if (me2hid_addr == NULL)
+		return -ENOMEM;
+
+	ipts->resources.hid2me_buffer.addr = addr;
+	ipts->resources.hid2me_buffer.dma_addr = dma_addr;
+	ipts->resources.hid2me_buffer_size = ipts->device_info.feedback_size;
+	ipts->resources.me2hid_buffer = me2hid_addr;
+
+	for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+		ipts->resources.feedback_buffer[parallel_idx].addr = dmam_alloc_coherent(&ipts->cldev->dev,
+				ipts->device_info.feedback_size,
+				&ipts->resources.feedback_buffer[parallel_idx].dma_addr,
+				GFP_ATOMIC|__GFP_ZERO);
+
+		if (ipts->resources.feedback_buffer[parallel_idx].addr == NULL)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void ipts_free_common_resource(ipts_info_t *ipts)
+{
+	int parallel_idx;
+
+	if (ipts->resources.me2hid_buffer) {
+		devm_kfree(&ipts->cldev->dev, ipts->resources.me2hid_buffer);
+		ipts->resources.me2hid_buffer = 0;
+	}
+
+	if (ipts->resources.hid2me_buffer.addr) {
+		dmam_free_coherent(&ipts->cldev->dev, ipts->resources.hid2me_buffer_size, ipts->resources.hid2me_buffer.addr, ipts->resources.hid2me_buffer.dma_addr);
+		ipts->resources.hid2me_buffer.addr = 0;
+		ipts->resources.hid2me_buffer.dma_addr = 0;
+		ipts->resources.hid2me_buffer_size = 0;
+	}
+
+	for (parallel_idx = 0; parallel_idx < TOUCH_SENSOR_MAX_DATA_BUFFERS; parallel_idx++) {
+		if (ipts->resources.feedback_buffer[parallel_idx].addr) {
+			dmam_free_coherent(&ipts->cldev->dev,
+				ipts->device_info.feedback_size,
+				ipts->resources.feedback_buffer[parallel_idx].addr,
+				ipts->resources.feedback_buffer[parallel_idx].dma_addr);
+			ipts->resources.feedback_buffer[parallel_idx].addr = 0;
+			ipts->resources.feedback_buffer[parallel_idx].dma_addr = 0;
+		}
+	}
+}
+
+int ipts_allocate_resources(ipts_info_t *ipts)
+{
+	int ret;
+
+	ret = ipts_allocate_common_resource(ipts);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "cannot allocate common resource\n");
+		return ret;
+	}
+
+	ret = setup_kernel(ipts);
+	if (ret) {
+		dev_err(&ipts->cldev->dev, "cannot allocate raw data resource\n");
+		ipts_free_common_resource(ipts);
+		return ret;
+	}
+
+	ipts->resources.allocated = true;
+
+	return 0;
+}
+
+void ipts_free_resources(ipts_info_t *ipts)
+{
+	if (!ipts->resources.allocated)
+		return;
+
+	ipts->resources.allocated = false;
+
+	release_kernel(ipts);
+
+	ipts_free_common_resource(ipts);
+}
diff -ruN a/drivers/misc/ipts/resources.h b/drivers/misc/ipts/resources.h
--- a/drivers/misc/ipts/resources.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/misc/ipts/resources.h	2019-11-01 16:57:47.340705625 +0100
@@ -0,0 +1,138 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _IPTS_RESOURCE_H_
+#define _IPTS_RESOURCE_H_
+
+typedef enum {
+	IPTS_BIN_KERNEL,
+	IPTS_BIN_RO_DATA,
+	IPTS_BIN_RW_DATA,
+	IPTS_BIN_SENSOR_FRAME,
+	IPTS_BIN_OUTPUT,
+	IPTS_BIN_DYNAMIC_STATE_HEAP,
+	IPTS_BIN_PATCH_LOCATION_LIST,
+	IPTS_BIN_ALLOCATION_LIST,
+	IPTS_BIN_COMMAND_BUFFER_PACKET,
+	IPTS_BIN_TAG,
+} ipts_bin_res_type_t;
+
+typedef struct ipts_bin_header {
+	char str[4];
+	unsigned int version;
+	unsigned int gfxcore;
+	unsigned int revid;
+} ipts_bin_header_t;
+
+typedef struct ipts_bin_alloc {
+	unsigned int handle;
+	unsigned int reserved;
+} ipts_bin_alloc_t;
+
+typedef struct ipts_bin_alloc_list {
+	unsigned int num;
+	ipts_bin_alloc_t alloc[];
+} ipts_bin_alloc_list_t;
+
+typedef struct ipts_bin_cmdbuf {
+	unsigned int size;
+	char data[];
+} ipts_bin_cmdbuf_t;
+
+typedef struct ipts_bin_res {
+	unsigned int handle;
+	ipts_bin_res_type_t type;
+	unsigned int initialize;
+	unsigned int aligned_size;
+	unsigned int size;
+	char data[];
+} ipts_bin_res_t;
+
+typedef struct ipts_bin_io_header {
+	char str[10];
+	unsigned short type;
+} ipts_bin_io_header_t;
+
+typedef struct ipts_bin_res_list {
+	unsigned int num;
+	ipts_bin_res_t res[];
+} ipts_bin_res_list_t;
+
+typedef struct ipts_bin_patch {
+	unsigned int index;
+	unsigned int reserved1[2];
+	unsigned int alloc_offset;
+	unsigned int patch_offset;
+	unsigned int reserved2;
+} ipts_bin_patch_t;
+
+typedef struct ipts_bin_patch_list {
+	unsigned int num;
+	ipts_bin_patch_t patch[];
+} ipts_bin_patch_list_t;
+
+typedef struct ipts_bin_guc_wq_info {
+	unsigned int batch_offset;
+	unsigned int size;
+	char data[];
+} ipts_bin_guc_wq_info_t;
+
+typedef struct ipts_bin_bufid_patch {
+	unsigned int imm_offset;
+	unsigned int mem_offset;
+} ipts_bin_bufid_patch_t;
+
+typedef struct bin_workload {
+	int cmdbuf_index;
+	int iobuf_input;
+	int iobuf_output[MAX_NUM_OUTPUT_BUFFERS];
+} bin_workload_t;
+
+typedef struct bin_buffer {
+	unsigned int handle;
+	ipts_mapbuffer_t *buf;
+} bin_buffer_t;
+
+typedef struct bin_alloc_info {
+	bin_buffer_t *buffs;
+	int num_of_allocations;
+	int num_of_outputs;
+	int num_of_buffers;
+} bin_alloc_info_t;
+
+typedef struct bin_guc_wq_item {
+	unsigned int batch_offset;
+	unsigned int size;
+	char data[];
+} bin_guc_wq_item_t;
+
+typedef struct bin_kernel_info {
+	bin_workload_t *wl;
+	bin_alloc_info_t *alloc_info;
+	bin_guc_wq_item_t *guc_wq_item;
+	ipts_bin_bufid_patch_t bufid_patch;
+	ipts_mapbuffer_t *bufid_buf;
+} bin_kernel_info_t;
+
+typedef struct bin_parse_info {
+	u8 *data;
+	int size;
+	int parsed;
+} bin_parse_info_t;
+
+void ipts_free_resources(ipts_info_t *ipts);
+int ipts_allocate_resources(ipts_info_t *ipts);
+
+#endif // _IPTS_RESOURCE_H_
diff -ruN a/drivers/misc/Kconfig b/drivers/misc/Kconfig
--- a/drivers/misc/Kconfig	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/misc/Kconfig	2019-11-01 16:57:47.340705625 +0100
@@ -519,6 +519,7 @@
 source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
+source "drivers/misc/ipts/Kconfig"
 source "drivers/misc/mei/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 source "drivers/misc/mic/Kconfig"
diff -ruN a/drivers/misc/Makefile b/drivers/misc/Makefile
--- a/drivers/misc/Makefile	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/misc/Makefile	2019-11-01 16:57:47.340705625 +0100
@@ -43,6 +43,7 @@
 obj-y				+= lis3lv02d/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
+obj-$(CONFIG_INTEL_IPTS)	+= ipts/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
diff -ruN a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h
--- a/drivers/misc/mei/hw-me-regs.h	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/misc/mei/hw-me-regs.h	2019-11-01 16:57:47.340705625 +0100
@@ -119,6 +119,7 @@
 
 #define MEI_DEV_ID_SPT        0x9D3A  /* Sunrise Point */
 #define MEI_DEV_ID_SPT_2      0x9D3B  /* Sunrise Point 2 */
+#define MEI_DEV_ID_SPT_4      0x9D3E  /* Sunrise Point 4 */
 #define MEI_DEV_ID_SPT_H      0xA13A  /* Sunrise Point H */
 #define MEI_DEV_ID_SPT_H_2    0xA13B  /* Sunrise Point H 2 */
 
diff -ruN a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
--- a/drivers/misc/mei/init.c	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/misc/mei/init.c	2019-11-01 16:57:47.340705625 +0100
@@ -310,10 +310,11 @@
 {
 	dev_dbg(dev->dev, "stopping the device.\n");
 
+	mei_cl_bus_remove_devices(dev);
+
 	mutex_lock(&dev->device_lock);
 	dev->dev_state = MEI_DEV_POWER_DOWN;
 	mutex_unlock(&dev->device_lock);
-	mei_cl_bus_remove_devices(dev);
 
 	mei_cancel_work(dev);
 
diff -ruN a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
--- a/drivers/misc/mei/pci-me.c	2019-07-21 09:03:18.000000000 +0200
+++ b/drivers/misc/mei/pci-me.c	2019-11-01 16:57:47.340705625 +0100
@@ -86,6 +86,7 @@
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT, MEI_ME_PCH8_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_2, MEI_ME_PCH8_CFG)},
+	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_4, MEI_ME_PCH8_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H, MEI_ME_PCH8_SPS_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H_2, MEI_ME_PCH8_SPS_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_LBG, MEI_ME_PCH12_CFG)},
diff -ruN a/include/linux/intel-ipts.h b/include/linux/intel-ipts.h
--- a/include/linux/intel-ipts.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/linux/intel-ipts.h	2019-11-01 17:01:06.858857250 +0100
@@ -0,0 +1,139 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _LINUX_INTEL_IPTS_H_
+#define _LINUX_INTEL_IPTS_H_
+
+#include <linux/hid.h>
+#include <linux/mei_cl_bus.h>
+
+#define MAX_NUM_OUTPUT_BUFFERS		16
+#define TOUCH_SENSOR_MAX_DATA_BUFFERS   16
+
+typedef struct ipts_buffer_info {
+	char *addr;
+	dma_addr_t dma_addr;
+} ipts_buffer_info_t;
+
+typedef struct ipts_wq_info {
+	u64 db_addr;
+	u64 db_phy_addr;
+	u32 db_cookie_offset;
+	u32 wq_size;
+	u64 wq_addr;
+	u64 wq_phy_addr;
+	u64 wq_head_addr;
+	u64 wq_head_phy_addr;
+	u64 wq_tail_addr;
+	u64 wq_tail_phy_addr;
+} ipts_wq_info_t;
+
+typedef struct ipts_resources {
+	ipts_buffer_info_t feedback_buffer[TOUCH_SENSOR_MAX_DATA_BUFFERS];
+	ipts_buffer_info_t hid2me_buffer;
+	ipts_buffer_info_t raw_data_mode_output_buffer[TOUCH_SENSOR_MAX_DATA_BUFFERS][MAX_NUM_OUTPUT_BUFFERS];
+	ipts_buffer_info_t touch_data_buffer_raw[TOUCH_SENSOR_MAX_DATA_BUFFERS];
+	ipts_wq_info_t wq_info;
+	u8 wq_item_size;
+	u32 hid2me_buffer_size;
+	u64 kernel_handle;
+	int last_buffer_completed;
+	int *last_buffer_submitted;
+	int num_of_outputs;
+	char *me2hid_buffer;
+	bool allocated;
+} ipts_resources_t;
+
+typedef enum ipts_state {
+	IPTS_STA_NONE,
+	IPTS_STA_INIT,
+	IPTS_STA_RESOURCE_READY,
+	IPTS_STA_HID_STARTED,
+	IPTS_STA_RAW_DATA_STARTED,
+	IPTS_STA_STOPPING
+} ipts_state_t;
+
+typedef enum touch_sensor_mode
+{
+	TOUCH_SENSOR_MODE_HID = 0,
+	TOUCH_SENSOR_MODE_RAW_DATA,
+	TOUCH_SENSOR_MODE_SENSOR_DEBUG = 4,
+	TOUCH_SENSOR_MODE_MAX
+} touch_sensor_mode_t;
+
+typedef enum touch_freq
+{
+	TOUCH_FREQ_RSVD = 0,
+	TOUCH_FREQ_17MHZ,
+	TOUCH_FREQ_30MHZ,
+	TOUCH_FREQ_MAX
+} touch_freq_t;
+
+typedef enum touch_spi_io_mode
+{
+	TOUCH_SPI_IO_MODE_SINGLE = 0,
+	TOUCH_SPI_IO_MODE_DUAL,
+	TOUCH_SPI_IO_MODE_QUAD,
+	TOUCH_SPI_IO_MODE_MAX
+} touch_spi_io_mode_t;
+
+typedef struct touch_sensor_get_device_info_rsp_data
+{
+	u16 vendor_id;
+	u16 device_id;
+	u32 hw_rev;
+	u32 fw_rev;
+	u32 frame_size;
+	u32 feedback_size;
+	touch_sensor_mode_t sensor_mode;
+	u32 max_touch_points				:8;
+	touch_freq_t spi_frequency			:8;
+	touch_spi_io_mode_t spi_io_mode			:8;
+	u32 reserved0					:8;
+	u8 sensor_minor_eds_rev;
+	u8 sensor_major_eds_rev;
+	u8 me_minor_eds_rev;
+	u8 me_major_eds_rev;
+	u8 sensor_eds_intf_rev;
+	u8 me_eds_intf_rev;
+	u8 kernel_compat_ver;
+	u8 reserved1;
+	u32 reserved2[2];
+} touch_sensor_get_device_info_rsp_data_t;
+
+typedef struct ipts_info {
+	struct hid_device *hid;
+	struct mei_cl_device *cldev;
+	ipts_resources_t resources;
+	ipts_state_t state;
+	touch_sensor_get_device_info_rsp_data_t device_info;
+	char *hardware_id;
+} ipts_info_t;
+
+typedef struct ipts_mapbuffer {
+	u32 size;
+	u32 flags;
+	void *gfx_addr;
+	void *cpu_addr;
+	u64 buf_handle;
+	u64 phy_addr;
+} ipts_mapbuffer_t;
+
+int intel_ipts_map_buffer(ipts_mapbuffer_t *mapbuf);
+int intel_ipts_unmap_buffer(uint64_t buf_handle);
+int intel_ipts_connect(ipts_info_t *ipts, void *intel_ipts_handle_processed_data);
+void intel_ipts_disconnect(void);
+
+#endif // _LINUX_INTEL_IPTS_H_
